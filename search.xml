<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java对象数组与基本类型数组]]></title>
    <url>%2F2021%2F06%2F04%2Fjava-object-arrays-and-base-arrays%2F</url>
    <content type="text"><![CDATA[对象数组和基本类型数组有什么不同？最近在看一本书，书名叫《软件困局：为什么聪明的程序员会写出糟糕的代码》，作者在第四章提到了C语言的数组。由此我想的了Java的数组，并在脑海里衍生出了一个问题。那就是 对象数组 和 基本数据数组 的区别。乍一看两者都是数组，能有什么区别？但仔细一想发现不对。我们都知道数组是支持按下标 随机访问 的，算法复杂度为O(1)。之所以有如此快的访问速度是因为数组的每个元素所占用的大小是固定的。这样我们只需要知道头结点的地址，就可以推算出任意一个元素的地址。 像java中的int(4字节)，long(8字节)等基本数据类型它们所占用的空间是固定的，所以数组能够随机访问很正常。但对象则不一样，拿String举例，每一个String对象所占用的空间是不一样的。数组该如何分配空间，以支持随机访问呢？这个问题我思考了很久，难道对象数组有着与基本数据类型数组不一样的实现方式吗？经过在网络一番查找，我得到了大致想要的答案。 直接说结论，那就是基本数据类型数组存放的是基本类型的值，对象数组存的是句柄（指针）。每个句柄（指针）所占用的空间是相同的，所以支持随机访问， 只不过对象数组需要比基本数据类型多一次寻址 （最后一句话仅是个人理解，不一定准确）。 我首先找到的是一篇博客 https://blog.csdn.net/z_ssyy/article/details/104521222 ，根据他的排版，感觉也是从其他地方摘抄的，内容并不完全。其中有这么一句话“ 唯一的差别在于对象数组容纳的是句柄，而基本数据类型数组容纳的是具体的数值 ”。后续我也尝试对这句话进行取证，先是准备查Java编程思想，看看其中有没有对数组的解释，但由于纸质书在老家，微信读书电子版只能试读，所以放弃。后续查阅了Java核心技术，发现当中并没有对应的解释。于是只能从《Java语言规范》和《Java虚拟机规范》找答案。 我并没有找到确切描述两者不同的文字，但可以从部分描述中推断出一部分信息。首先在《Java语言规范》的第四章 https://docs.oracle.com/javase/specs/jls/se16/html/jls-4.html ，有这么一段话： The values of a reference type are references to objects 引用类型的值是对对象的引用，通过这句话我们可以推导出对象数组中存放的就是对象的引用。通过这句话也发现了自己以前的一个误区。那就是以前以为变量指向的就是数据，实际上变量指向的是数据的引用地址，需要再次寻址才能拿到真正的数据。 A variable of a primitive type always holds a primitive value of that exact primitive type. 这句话说明了基本数据类型，指向的就是值，没有引用。 思考基本数据类型和引用数据类型的本质差别是什么？ 将数据映射到硬件上，其实所有数据都应该有着自己的地址。不管是基本数据类型，还是引用数据类型。以下均为个人理解： 如图： 基本数据类型实际上只占用一块空间，而引用数据类型需要占用两块空间（注意每块空间的大小是不一样的）。这样我们对基本数据类型的修改，实际上改的就是地址01里面的值。对引用数据类型修改就会有两种情况，一种改的是03的值，一种改的的02的引用。举一个例子： 123456789101112131415161718192021222324252627282930313233343536public static void main(String[] args) &#123; ArrayList&lt;String&gt; arrays = new ArrayList&lt;&gt;(); arrays.add("10"); arrays.add("20"); arrays.add("30"); System.out.println("未修改：" + arrays); updateVal(arrays); System.out.println("修改值：" + arrays); List&lt;String&gt; newArrays = updateRef(arrays); System.out.println("修改引用：" + arrays); System.out.println("新引用值：" + newArrays);&#125;/** * 修改的是03地址当中的值 * * @param arrays 原集合 */private static void updateVal(List&lt;String&gt; arrays) &#123; arrays.set(1, "1");&#125;/** * 修改的是02地址中的值，将02地址中的引用指向了04 * * @param arrays 原集合 * @return 新集合 */private static List&lt;String&gt; updateRef(List&lt;String&gt; arrays) &#123; List&lt;String&gt; newArrays = new ArrayList&lt;&gt;(); newArrays.add("hello"); arrays = newArrays; arrays.add("40"); arrays.add("50"); return arrays;&#125;]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随笔(01)]]></title>
    <url>%2F2021%2F05%2F12%2Finformal-essay%2F</url>
    <content type="text"><![CDATA[​ 博客有很久都没有更新了，2020年底立下的flag一个也没完成。20年底说着每周一更，每月4更，到今天已经5月份了，算下来欠下了将近20篇文章。原因有很多方面，一方面是自己精力有限，另一方面是由于感觉自己学的东西不成体系，太过零散，没办法凑出一篇博客的内容。所以就没往博客上发，发在了新的随笔上，链接如下：个人随笔,后续会把链接放到友链上，方便访问。 ​ 说一下这几个月来的成果，年初一段时间基本都在为了换工作而在疯狂的背八股文。工作稳定后也在思考，感觉光靠被八股文不够，对某些东西的理解还是不够透彻，都是靠死记硬背。就像提到HashMap就想到数组+链表+红黑树。你说真正理解了吗？其实并没有，数组到链表其实还好理解，但到了红黑树就一问三不知了，到现在为止我也没搞清楚红黑树的定义，以及是如何实现的。这只是一部分。花时间仍然可以去理解，不算太大的瓶颈。主要的瓶颈在kafka等类似的中间件上，比如说kafka是分区有序的，数据是顺序写。但道理是如何实现顺序写了没有一篇文章去讲清楚。这时候已经明显的感觉到软件知识已经不够用了。需要结合硬件一起来看待。不去了解硬件你根本不会理解顺序写、随机写到底是什么。软件学到最后真的发现就是：数据结构+算法，甚至有些时候觉得两者就是一个东西。 ​ 计算机科学速成课给了我很大的启发，它让我感觉到以前的学习方向都是错误的。觉得曾经学习的知识都太过上层了，无法融会贯通。看了几章视频后我发现，可能作为2一个软件工程师就不应该分什么前后端，甚至语言在我眼里也变得不重要。因为无论什么语言无非都是对二进制的高度抽象，最终传输给计算机的还是一个一个”0”,”1”字符。这时候才发现自己原来所看待问题的方式太过上层了，不管什么语言语法，始终都是建立在硬件之上的，”九层之台，起于累土“。只有真正的理解了硬件的实现，才能更好的去理解软件。最后的最后软件剩下的只有：架构的核心思想+数据结构+算法，三者组成了软件的灵魂。 ​ 后续一周一更的博客应该是很难实现了，觉得目前的自己太过于浮躁了，需要花时间好好的沉淀一下。去思考如何抛开语言，抛开前后端的思考问题。一个优秀的程序员不应该被语言牵绊。诚然，每门语言都有各自的特性，每个方向都有各自的知识，一个人是不可能学尽所有的知识的。目前其实自己的方向还不是很明朗，始终无法贯通前后端和各个技术栈。看过“左耳朵耗子”、七牛云CEO”许式伟“、刘超等各位大牛的几篇文章后，发现他们好像已经摆脱了语言，方向的束缚。可以和你从java聊到go，从前端聊到后端，从redis聊到kubernetes。希望自己有朝一日能够达到他们这样的水准。 ​ 最后再重新立一下flag，以后博客两周一更新，随笔基本上会随时更。后续的重点方向应该会放在计算机组成原理这块。也会花部分时间继续学习应用层的知识，两者各占一半吧。其实说了那么久自己都是站在一个技术人的角度思考，后续应该也会跳出技术人的桎梏，去思考一下自己的人生。]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程（01）—— 常用api解析]]></title>
    <url>%2F2021%2F01%2F06%2Fjava-concurrent-01%2F</url>
    <content type="text"><![CDATA[以前其实写过几篇和多线程有关的东西，但感觉都不成体系。随着对并发编程的深入，想系统的整理一下所学所想。一是可以和大家分享，二是可以给自己查漏补缺。先从最基础的常用api聊起。 序言先说一下我认为学习多线程常用到的api java.lang.Object#wait(long)：是一个重载方法有多种形式，但最终调用的都是java.lang.Object#wait(long)，调用该方法代表着挂起当前线程，释放掉持有的锁，直到有其他线程调用notify或notifyAll方法唤醒该线程，才能再次争抢锁。 注：wait方法必须在synchronized代码块中调用否则会抛出java.lang.IllegalMonitorStateException异常 java.lang.Object#notify：随机唤起一个调用wait方法而等待的线程 java.lang.Object#notifyAll：唤起全部应调用wait方法而等待的线程 注：若为特殊情况推荐使用notifyAll方法唤醒等待线程，因为notify随机唤醒的特性可能会导致线程饥饿，导致部分线程一直无法获取到锁 java.lang.Thread#sleep(long)：使当前线程休眠指定的毫秒数，不会释放锁 java.lang.Thread#join(long)：本质上调用的就是wait方法，使当前线程等待 java.lang.Thread#yield：向调度器表示当前线程愿意让出当前CPU的执行权，但调度器可以忽略这点。 常见的生产者消费者模型1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.yuehua.concurrent.demo;import java.util.PriorityQueue;import java.util.Queue;/** * * 简单的生产者-消费者模型 * * @author yuehua * @version v1.0 * @since 2021/1/6 13:54 */public class WaitDemo &#123; private static final Queue&lt;Integer&gt; QUEUE = new PriorityQueue&lt;&gt;(); public static void main(String[] args) &#123; new Thread(WaitDemo::poll).start(); new Thread(WaitDemo::offer).start(); &#125; /** * 生产数据 */ private static void offer() &#123; while (true) &#123; synchronized (QUEUE) &#123; while (QUEUE.size() &lt; 10) &#123; System.out.println("生产数据"); QUEUE.offer(0); QUEUE.notifyAll(); &#125; try &#123; QUEUE.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; /** * 消费数据 */ private static void poll()&#123; while (true) &#123; synchronized (QUEUE) &#123; while (QUEUE.size() == 0) &#123; try &#123; QUEUE.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; QUEUE.notifyAll(); &#125; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("消费数据 "+ Thread.currentThread().getName()); QUEUE.poll(); &#125; &#125; &#125;&#125; 运行以上代码我们会发现有一个问题，那就是生产者必须等待消费者消费完所有数据才能继续生产，消费者也是同理。理想情况下应该是只要队列不满生产者就可以继续生产，只要队列不空消费者就可以继续消费]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020年末总结]]></title>
    <url>%2F2020%2F12%2F31%2F2020-last-day%2F</url>
    <content type="text"><![CDATA[序言 转眼间2020年就过去了，在2020年的最后一天，也该写一篇总结给自己一个交代。写总结的目的是为了反思过去，同时也是为了展望未来。 回首过去 回首2020年，不管是对我还是对整个世界来说，应该都是糟糕的一年。新冠疫情席卷全球，好在国内发现及时，基本已经控制下来了。但看着国外每日数以万计的新增病例，还是感到触目惊心。 近两年明显感到自己对技术方面松懈了，不像当年在学校时一样废寝忘食的学习，会去看各种视频、博客。总结下来原因大概有以下几点 不像在学校一样有大把空余时间去学习，工作后需要把绝大部分精力投入到业务上 日子过得太安逸，没有外力推动去进步 懒，学习始终是枯燥无味的。不如打两把游戏、刷几条抖音来的轻松 正向反馈 忘记了是在哪本书中看到正向反馈这个词了，在我理解来这个词的大致意思就是：做任何事情，都是需要激励与鼓舞的。拿玩游戏来说，玩游戏的正向反馈就是“我可以去刷一个BOSS，刷完BOSS后能使我变得更强，变强之后我就有能力刷更强大的boss”。这样就会形成一个良性循环。学习也是同理，但学习要找的正向反馈比较难。这是由于学习的正向反馈周期比较长，可能你学了很长时间，你依然不知道你所学习的知识能干嘛。会感到迷茫，学了半天感觉自己所学知识无用武之地。 自己之所以对技术产生松懈，也是由于缺乏正向反馈。感觉自己掌握的知识可以应付绝大部分业务开发了，处在一个温水区，让人失去对进步的渴望，没有动力去学习。其实公司目前还有很多东西需要去完善 应用没有负载均衡，每次停机部署至少需要暂停服务30秒到1分钟。这对互联网公司来说其实是不可接受的 应用部署流程不完善，新应用上线仍需运维手工修改nginx配置，不能一键化部署。部署过程缓慢，jenkins和应用服务器不在同一个内网服务器导致服务部署经常需要5-10分钟。 绝大部分应用都是有状态的，难以做集群化部署。例：定时任务、延时队列、session等。没有统一的集中化定时调度平台。若集群化部署会导致相同任务在多应用中并发执行 基础设施极度匮乏，后端无统一支付中台、短信中台，各业务方需自行实现支付状态同步重复造轮子，若实现不合理甚至会出现重复支付的可能。目前的短信提供商存在单点问题，严重情况下会导致所有用户无法登陆注册。前端缺乏业务组件、部署环境、版本管理等，绝大部分页面都是CV大法，费时费力 上面列出来的只是一部分，其中还有很多问题等待着研发部门去解决。当中的任何一个问题，都值得深入去研究，思考如何优化。部分问题自己也有尝试去推动解决，但由于各种各样的原因导致最后还是不了了之。 权限不足，很多事情没法推动 缺乏并肩作战的伙伴，独木难支 无人引领方向，摸着石头过河，导致有些方案不足以在生产环境运行 2020读过的书 20年读过的书不多，基本上都列在了21年的必读书单上。除了张亮的《未来架构：从服务化到云原生》好像没一本完整读完的书籍，所以21年要继续把这些书读完。虽然也买了不少纸质书，但大部分时间还是用微信读书，看了一下统计今年在微信读书上花的时间才106小时，平均一天不到20分钟。21年应该会把每日阅读量提升到一个小时。最近好像由于版权问题，微信读书上的不少好书只能试读了，后续可能还是得购买纸质书籍。 展望未来主要方向 2021年的主要方向还是补充基础知识，重点学习方向JVM、并发编程、MySQL存储引擎、Linux基础。基础稳固后消息中间件及缓存中间件是第二大学习方向。第三大方向会去深入理解分布式系统的一些概念（这块内容比较多，但市面上没有什么特别好的实战书籍，大多数都是浅尝辄止。今年重点学习分布式一致性协议及分布式事务。）。如果还有时间的话会去看看云原生的生态体系，如Kubernetes，Service Mesh，Serverless、Prometheus等。 它山之石 可以攻玉 以上列举的基本都是后端知识，后端学累了的话，也会看看前端。React会是重点方向。重点学习的不是React的语法，而是核心部分。如JSX的本质，虚拟DOM和diff算法，React是如何解析并最终渲染出HTML，路由是如何实现的的等等。架构的核心思想其实不分什么前后端，思想终究是通用的，要学的是思想，而非应用。 2021主要书单及专栏必读书单 《深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）》—— 周志明 《MySQL技术内幕：InnoDB存储引擎(第2版)》—— 姜承尧 《深入理解Kafka：核心设计与实践原理》—— 朱忠华 《Kubernetes权威指南：从Docker到Kubernetes实践全接触（第4版）》—— 龚正、吴治辉、王伟、崔秀龙、闫健勇、崔晓宁、刘晓红 《Java并发编程的艺术》—— 方腾飞 《Redis设计与实现》—— 黄建宏 《Docker：容器与容器云（第2版）》—— 浙江大学SEL实验室 选读书单 《高性能MySQL》 《深入理解计算机系统》 《RabbitMQ实战指南》 《鸟哥的Linux私房菜》 《分布式系统：概念与设计》 专栏 《Java并发编程实战》—— 王宝令 《MySQL实战45讲》—— 林晓斌（丁奇） 《数据结构与算法之美》—— 王争 《设计模式之美》—— 王争 《深入剖析Kubernetes》—— 张磊 官方文档及博客Java语言和虚拟机规范 Java相关文档 MySql官方文档 阿里云RDS-数据库内核组 美团技术博客 软件架构探索-周志明 本来还有一个阿里云中间件团队的博客，但在几个月前无法访问了。原博客地址：阿里中间件团队博客 关于博客 20年博客基本没怎么写，21年应该会做的每周至少1更，一个月4更的状态。把自己的所学所想转换为文字记录下来，更有助于技术水平的提高。同时也是对自己的一个督促，每周一篇的更新促使自己进步。 总结 参加工作近两年，自己也在不知不觉中成长，不管是工作上还是生活上，都不像两年前那么稚嫩。从前总觉得自己到了瓶颈期，技术方面没什么长进，但现在回看两年前的代码，才发现自己还是有一定的进步的。瓶颈期总是在不知不觉中突破，技术是需要时间沉淀的，人也一样，欲速则不达。最后以韩愈的一句话结尾，与大家共勉： 业精于勤，荒于嬉；行成于思，毁于随。——《进学解》韩愈]]></content>
      <categories>
        <category>个人成长</category>
      </categories>
      <tags>
        <tag>年终总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逻辑删除和唯一索引]]></title>
    <url>%2F2020%2F08%2F29%2Flogical-deletion-and-unique-index%2F</url>
    <content type="text"><![CDATA[背景现在基本上开发过程中都会使用到逻辑删除，但当逻辑删除与唯一索引一起存在时可能会导致一些问题。 问题起因一天收到测试提的一个bug，然后对问题进行排查，发现是由于唯一索引冲突导致的无法插入数据造成的问题，当时很费解，因为该唯一索引字段已经在业务层做了唯一性校验理论上不应该出现索引冲突的问题啊！后来仔细一想发现应该是逻辑删除和唯一索引一起使用时导致的问题。下面开始对问题进行分析，为方便分析对表结构进行了简化。 问题分析表结构123456CREATE TABLE `test`.`user` ( `id` bigint(20) NOT NULL COMMENT '主键', `is_deleted` tinyint(4) NULL COMMENT '逻辑删除', `username` varchar(255) NULL COMMENT '用户名（唯一）', PRIMARY KEY (`id`)); 表索引12ALTER TABLE `test`.`user` ADD UNIQUE INDEX `uk_username`(`username`) USING BTREE COMMENT '用户名唯一索引'; 说明：is_deleted字段为逻辑删除字段，0为未删除，1：为已删除 首先我们先插入一条数据： 1INSERT INTO user ( id, is_deleted, username ) VALUES ( 1299617941335060482, 0, "hello" ) 然后我们再将这条数据以逻辑删除的方式删掉： 1UPDATE user SET is_deleted=1 WHERE id=1299617941335060482 AND is_deleted=0 当我们想再次插入username为”hello”的数据时就会发生唯一索引冲突： 1INSERT INTO user ( id, is_deleted, username ) VALUES ( 1299619108853121025, 0, "hello" ) Duplicate entry ‘hello’ for key ‘uk_username’ 此时数据库数据状态： id is_deleted username 1299617941335060482 1 hello 原因相信大家都很清楚，这是由于逻辑删除并未真正的删除表中的数据，哪怕此时我们在业务层做了唯一性校验依然会出现这种问题。因为唯一性校验的SQL默认会拼接上逻辑索引字段，导致无法查出相应数据，最终引发了Duplicate entry &#39;hello&#39; for key &#39;uk_username&#39; 唯一校验SQL： 1SELECT id,is_deleted,username FROM user WHERE is_deleted=0 AND (username = "hello") 如何处理？初步解决方案一开始想着既然是由于唯一索引冲突导致的，那么我们就把is_deleted和username建立成联合唯一索引不就好了吗？ 123ALTER TABLE `test`.`user` DROP INDEX `uk_username`,ADD UNIQUE INDEX `uk_username_and_is_deleted`(`username`, `is_deleted`) USING BTREE COMMENT '用户名唯一索引'; 此时数据库数据： id is_deleted username 1299617941335060482 1 hello 1299621533785911298 0 hello 加上唯一索引之后测试完插入语句发现确实没问题了，由于联合索引的缘故不会再出现和已删除的数据冲突的情况，但此时删除数据又会出现问题： 1UPDATE user SET is_deleted=1 WHERE id=1299621533785911298 AND is_deleted=0 当我们想删除id为1299621533785911298的数据时又会发生唯一索引冲突。 最终解决方案 去除唯一索引，业务层做完善校验（不推荐） 原因：业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。（阿里巴巴Java开发规范） 除非现有表结构中已经积累了大量数据，导致做全库DDL（DDL语句会锁整张表，不要轻易在线上做DDL操作）及数据迁移困难，否则不推荐采取该方案。 说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。 建立联合索引，is_deteled字段不要用单纯的0和1来表示，可以用0来表示正常数据，逻辑删除数据可以有以下几种方案来表示（推荐） 将删除标识的正常设为固定值,删除值使用叠加值(-1,-2,-3)（该方案需保证字段值为全局递增或全局递减，分布式环境下实现复杂） 将删除标识的删除状态设为id（推荐，使用主键确保不会发生索引冲突，并且实现简单） 若使用的是mybatis-plus框架可将logic-delete-value设置为如下： 1logic-delete-value: id 将删除标识设为当前时间戳（时间戳在极端情况下依旧有索引冲突的风险） 若使用的是mybatis-plus框架可将logic-delete-value设置为如下： 1logic-delete-value: REPLACE(unix_timestamp(current_timestamp(3)),'.','') 若采用该方案我们需对表结构进行一定的修改，因为原来的逻辑删除字段为tinyint(4)类型，长度不足以支撑该解决方案 12ALTER TABLE `test`.`user` MODIFY COLUMN `is_deleted` bigint(20) NULL DEFAULT NULL COMMENT '逻辑删除' AFTER `id`;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql-04-索引]]></title>
    <url>%2F2020%2F03%2F23%2Fmysql-04%2F</url>
    <content type="text"><![CDATA[序言数据库索引是在日常工作当中很常见的，面试时面试官问你对SQL优化有没有了解，也和索引息息相关。 一句话简单来说，索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。一本 500 页的书，如果你想快速找到其中的某一个知识点，在不借助目录的情况下，那我估计你可得找一会儿。同样，对于数据库的表而言，索引其实就是它的“目录”。 索引常见类型索引的出现是为了提高查询效率，但是实现索引的方式却有很多种。这里先介绍三种常见、也比较简单的数据结构，它们分别是哈希表、有序数组和搜索树。 哈希表哈希表是一种以键 - 值（key-value）存储数据的结构，我们只要输入待查找的键即 key，就可以找到其对应的值即 Value。哈希的思路很简单，把值放在数组里，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置。所以哈希表的查找效率很高，只需要O(1)的时间。 不可避免的可能会有多个key，经过计算后会出现同一个值的情况，这就是哈希冲突。遇见常见的哈希冲突就是在当前数组中拉出一个链表，当链表越长哈希查找的效率就越慢。所以一个好的哈希算法非常重要。 虽然哈希表查询的速度非常快，但它只适合等值查询，当遇到需要区间查询的数据时，就需要变量整张哈希表了。 所以，哈希表这种结构适用于只有等值查询的场景，比如 Memcached 及其他一些 NoSQL 引擎。 有序数组有序数组的区间查询和等值查询的性能都非常优秀，当需要查询一个对应的数值时，只需要用二分法就可以快速得到，这个时间复杂度是 O(log(N))。虽然不如哈希表的O(1)，但其性能仍十分优秀。 当执行区间查询时[value1,value2]，我们可以先使用二分查找找到value1(当value1不存在时找到比它大的第一个数)，然后向后遍历，直到查找的第一个大于value2的值。 如果只看查询效率的话，有序数组就是最优秀的数据结构了。但它的更新效率十分低下，为了维持数组的有序性，不得不耗费大量的时间来维护。 二叉搜索树二叉搜索树的特点就是：左子节点小于父节点，而父节点又小于右子节点，其等值查询的时间复杂度为O(log(N))。当然为了维持O(log(N))的时间复杂度，就必须保证当前的树是平衡二叉树，为了做这个保证，更新时间复杂度也是O(log(N))。 数可以有二叉，也可以有多叉，多叉树保证子节点从左到右依次递增。二叉树的搜索效率是最高的，但大多数数据库的储存结构都不是二叉树，其原因是索引不止要写到内存中，还需要写到磁盘上。 一棵 100 万节点的平衡二叉树，树高 20。一次查询可能需要访问 20 个数据块。在机械硬盘时代，从磁盘随机读一个数据块需要 10 ms 左右的寻址时间。也就是说，对于一个 100 万行的表，如果使用二叉树来存储，单独访问一个行可能需要 20 个 10 ms 的时间，这个查询可真够慢的。 为了让一个查询尽量少地读磁盘，我们可以使用“N叉”树减少数的高度，从而减少磁盘寻址时间，这里，“N 叉”树中的“N”取决于数据块的大小。 以 InnoDB 的一个整数字段索引为例，这个 N 差不多是 1200。这棵树高是 4 的时候，就可以存 1200 的 3 次方个值，这已经 17 亿了。考虑到树根的数据块总是在内存中的，一个 10 亿行的表上一个整数字段的索引，查找一个值最多只需要访问 3 次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。 N 叉树由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中了。 InnoDB 的索引模型由于 InnoDB 存储引擎在 MySQL 数据库中使用最为广泛，所以下面我就以 InnoDB 为例，和你分析一下其中的索引模型。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql-03-事务隔离级别]]></title>
    <url>%2F2020%2F03%2F11%2Fmysql-03%2F</url>
    <content type="text"><![CDATA[序言SQL 标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）。 事务ACID特性：ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性） 数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题，为了解决这些问题，就有了“隔离级别”的概念。 事务存在的原因简单来说，事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在 MySQL 中，事务支持是在引擎层实现的。你现在知道，MySQL 是一个支持多引擎的系统，但并不是所有的引擎都支持事务。比如 MySQL 原生的 MyISAM 引擎就不支持事务，这也是 MyISAM 被 InnoDB 取代的重要原因之一。 以下内容都是建立在InnoDB引擎下的 事务隔离级别 读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。 读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。 可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。 串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。 各事务隔离级别之间的区别12create table T(c int) engine=InnoDB;insert into T(c) values(1); 事务A 事务B 启动事务A查询到值1 启动事务 查询到值1 将1改成2 查询到值V1 事务提交 查询到值V2 事务提交 查询到值V3 各种隔离级别下V1、V2、V3的值各是多少？ 读未提交：V1、V2、V3的值都是2，该隔离级别事务A可以读到事务B未提交的值 读提交：V1：1，V2、V3：2，该隔离级别事务A可以读到事务B提交后的值 可重复读：V1、V2：1，V3：2，该隔离级别确保在事务提交前，读到的值都是一致的 串行化：V1、V2：1，V3：2，该隔离级别在事务A未提交之前，事务B无法对值进行操作，只有等事务A结束释放锁后，事务B才能将值改为2 在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。 事务隔离级别的实现在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。 假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录。 read-view A read-view B read-view C 将2改为1 将3改为2 将4改为3 当前值4 当前值是 4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的 read-view。如图中看到的，在视图 A、B、C 里面，这一个记录的值分别是 1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于 read-view A，要得到 1，就必须将当前值依次执行图中所有的回滚操作得到。 回滚日志什么时候删除？答案是，在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。 什么时候才不需要了呢？就是当系统里没有比这个回滚日志更早的 read-view 的时候。 尽量不要使用长事务长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。 在 MySQL 5.5 及以前的版本，回滚日志是跟数据字典一起放在 ibdata 文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。 事务启动方式 显式启动事务语句， begin 或 start transaction。配套的提交语句是 commit，回滚语句是 rollback。 set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个 select 语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行 commit 或 rollback 语句，或者断开连接。 如何减少显式启动事务的begin语句？使用commit work and chain 语法 在 autocommit 为 1 的情况下，用 begin 显式启动的事务，如果执行 commit 则提交事务。如果执行 commit work and chain，则是提交事务并自动启动下一个事务，这样也省去了再次执行 begin 语句的开销。同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。 长事务查询方法你可以在 information_schema 库的 innodb_trx 这个表中查询长事务，比如下面这个语句，用于查找持续时间超过 60s 的事务 1select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))&gt;60 注意事项 Oracle的默认事务隔离级别为：读提交，而MySQL的默认事务隔离级别为：可重复读，所以在数据库迁移时需保证事务隔离级别一致，以免造成不必要的麻烦。 set autocommit=0 会导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务。建议使用 set autocommit=1, 通过显式语句的方式来启动事务。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql-02-日志系统]]></title>
    <url>%2F2020%2F03%2F10%2Fmysql-02%2F</url>
    <content type="text"><![CDATA[序言MySQL中的日志主要分为两种，1.redo log（重做日志）InnoDB独有；2.binlog（归档日志）MySQL Server层日志，跨引擎。 日志模块：redo log（重做日志）redo log是存储引擎层面的日志，为InnoDB独有。在执行更新数据库操作时都会向redo log中写入一条日志。 如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高。为了解决这个问题，MySQL采用了 WAL 技术，WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘。 具体来说，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做 InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写 如图： write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。 write pos 和 checkpoint 之间的是redo log还空着的部分，可以用来记录新的操作。如果 write pos 追上 checkpoint，表示日志满了，这时候不能再执行新的更新，得停下来先把部分数据存入磁盘，把 checkpoint 推进一下。 有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 crash-safe。 日志模块之binlog（归档日志）binlog是MySQL Server层的日志，与具体存储引擎实现无关。 为什么MySQL会存在两份日志？ 因为最开始 MySQL 里并没有 InnoDB 引擎。MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统——也就是 redo log 来实现 crash-safe 能力。 这两种日志有以下三点不同。 redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。 redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。 redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。 更新 SQL 执行流程： 找到需要更新的数据，若在内存中则直接返回；否则先从磁盘中读入内存在返回。 执行器拿到引擎给的数据，将数据更新得到新的一行数据，再调用引擎接口写入这行新数据。 引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。 执行器生成这个操作的 binlog，并把 binlog 写入磁盘。 执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。 InnoDB将redo log的写入拆成了两个步骤：prepare 和 commit，这就是”两阶段提交”。 两阶段提交为什么必须有“两阶段提交”呢？这是为了让两份日志之间的逻辑一致。 误删表数据恢复前面我们说过了，binlog 会记录所有的逻辑操作，并且是采用“追加写”的形式。如果你的 DBA 承诺说半个月内可以恢复，那么备份系统中一定会保存最近半个月的所有 binlog，同时系统会定期做整库备份。这里的“定期”取决于系统的重要性，可以是一天一备，也可以是一周一备。 如果发生误删表补救流程： 首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库； 然后，从备份的时间点开始，将备份的 binlog 依次取出来，重放到误删表之前的那个时刻。 这样你的临时库就跟误删之前的线上库一样了，然后你可以把表数据从临时库取出来，按需要恢复到线上库去。 两阶段提交存在的意义说完数据恢复，我们再来说说为什么需要两阶段提交 由于 redo log 和 binlog 是两个独立的逻辑，如果不用两阶段提交，要么就是先写完 redo log 再写 binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。 先写 redo log 后写 binlog。假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。由于我们前面说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来。但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。导致数据丢失。 先写 binlog 后写 redo log。如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效。但是 binlog 里面已经记录了这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的值与原库的值不同。 线上库推荐参数设置redo log 用于保证 crash-safe 能力。innodb_flush_log_at_trx_commit 这个参数设置成 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘。这个参数我建议你设置成 1，这样可以保证 MySQL 异常重启之后数据不丢失。 sync_binlog 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。这个参数我也建议你设置成 1，这样可以保证 MySQL 异常重启之后 binlog 不丢失。 疑问 两阶段提交如何保证commit的时候，redo log和binlog，都成功写入磁盘？假设redo log写完后系统出现异常，数据如何回滚？该操作的原子性是由操作系统保证的还是由MySQL来保证的？]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql-01-基础架构]]></title>
    <url>%2F2020%2F03%2F09%2Fmysql-01%2F</url>
    <content type="text"><![CDATA[序言本篇及后续mysql文章集合中的知识均来自于极客时间的《MySQL实战45讲》专栏，文章的目的只是为了对专栏学习的一个知识汇总。由于是对专栏知识的一个总体概括，可能每篇文章与专栏的顺序不是一一对应的。 主要内容MySQL主体架构MySQL的基本架构大体上可以分为Server层和存储引擎两个部分 Server层Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等 存储引擎而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。 连接器连接器负责跟客户端建立连接、获取权限、维持和管理连接 如果用户名或密码不对，你就会收到一个”Access denied for user”的错误，然后客户端程序结束执行。 如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。 这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。 建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。 MySQL长连接注意事项但是全部使用长连接后，你可能会发现，有些时候 MySQL 占用内存涨得特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。 解决方案 定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。 如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。 查询缓存MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。key 是查询的语句，value 是查询的结果。如果你的查询能够直接在这个缓存中找到 key，那么这个 value 就会被直接返回给客户端。 如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。你可以看到，如果查询命中缓存，MySQL 不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。 但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。 查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。 需要注意的是，MySQL 8.0 版本直接将查询缓存的整块功能删掉了，也就是说 8.0 开始彻底没有这个功能了。 分析器分析器先会做“词法分析”。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。 MySQL 从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。 做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。 优化器优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。 比如你执行下面这样的语句，这个语句是执行两个表的 join： 1mysql&gt; select * from t1 join t2 using(ID) where t1.c=10 and t2.d=20; 既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。 也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。 执行器SQL开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误，如下所示 (在工程实现上，如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证。查询也会在优化器之前调用 precheck 验证权限)。 如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。比如我们这个例子中的表 T 中，ID 字段没有索引，那么执行器的执行流程是这样的： 调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中； 调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。 对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建多线程方式之Callable]]></title>
    <url>%2F2019%2F06%2F07%2Fmultithreading-05%2F</url>
    <content type="text"><![CDATA[前言前面我们说到了实现多线程的两种方式，分别是实现Runnable接口和继承Thread类。那么实现Callable接口和他们有什么区别呢？ 通过Callable接口实现多线程1234567891011121314151617181920212223242526272829303132package com.example.socket.multithreading;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;public class CallableTest implements Callable &#123; @Override public Object call() &#123; int sum = 0; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(i); sum += i; &#125; return sum; &#125; public static void main(String[] args) &#123; CallableTest callableTest = new CallableTest(); FutureTask futureTask = new FutureTask(callableTest); Thread thread = new Thread(futureTask); thread.start(); try &#123; Object o = futureTask.get(); System.out.println("总和为：" + o); &#125; catch (InterruptedException | ExecutionException e) &#123; e.printStackTrace(); &#125; &#125;&#125; Callable与Runnable的异同 通过实现Callable接口我们可以获取方法的返回值 通过实现Callable接口我们可以抛出异常 通过实现Callable接口我们可以使用泛型定义方法的返回值]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Java多线程之线程间的通信]]></title>
    <url>%2F2019%2F06%2F06%2Fmultithreading-04%2F</url>
    <content type="text"><![CDATA[使用线程通信完成交替打印1-100实现原理实现线程间的交替打印主要是通过wait()和notify()两个方法。下面我们来讲一下几个相关方法的作用 注：以下3个方法都必须在同步代码块或同步方法中调用，否则会抛出java.lang.IllegalMonitorStateException异常 wait()：一旦执行该方法，当前线程就会进入阻塞状态，并释放同步监视器(意味着其他线程可以进入)。 notify()：一旦执行该方法，就会唤醒一个wait的线程，如果有多个线程wait，则唤醒优先级最高的那个。 notifyAll()：一旦执行该方法，会唤醒所有被wait的线程。 实现代码1234567891011121314151617181920212223242526272829303132333435363738package com.example.socket.multithreading;class RunnableImpl2 implements Runnable &#123; private int num = 1; @Override public void run() &#123; while (true) &#123; synchronized (this) &#123; notify(); if (num &lt;= 100) &#123; System.out.println(Thread.currentThread().getName() + ":" + num); num++; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; else &#123; break; &#125; &#125; &#125; &#125;&#125;public class CommunicationThread &#123; public static void main(String[] args) &#123; Runnable runnable = new RunnableImpl2(); Thread thread1 = new Thread(runnable); Thread thread2 = new Thread(runnable); thread1.setName("线程1"); thread2.setName("线程2"); thread1.start(); thread2.start(); &#125;&#125; 分析代码执行过程 注：以下描述的同步监视器等同于锁 我们以A、B来代替代码中的两个线程，首先两个线程其他，假设A抢到了CPU执行权，则执行run方法，首先线程A调用notify()方法，此时没有线程wait，所以不会唤醒任何线程，然后A打印出1，并执行num++，最后线程A调用wait()方法。此时线程A进入阻塞状态，释放同步监视器，线程B可以拿到锁。然后线程B调用notify()方法唤醒线程A，由于锁没释放，所以线程A暂时不能执行。最后线程B调用wait()方法，进入阻塞状态，释放同步监视器。然后线程A可以拿到锁，执行相应代码，如此循环往复就会出现交替打印的效果。 sleep与wait方法有什么区别？相同点执行这两个方法后都会使线程进入阻塞状态 不同点 sleep方法声明在Thread类中，而wait方法声明咋Object类当中。 sleep方法可以在任意场景当中调用，而wait方法只能在同步代码块或同步方法中调用。 sleep方法调用后不会释放同步监视器，而wait方法调用后会释放同步监视器。 生产者消费者问题问题描述生产者和消费者问题是线程模型中的经典问题：生产者和消费者在同一时间段内共用同一个存储空间，生产者往存储空间中添加产品，消费者从存储空间中取走产品，当存储空间为空时，消费者阻塞，当存储空间满时，生产者阻塞。 实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package com.example.socket.multithreading;/** * 负责通知生产和消费的店员 */class Clerk &#123; private static Integer num = 0; public synchronized void product() &#123; if (num &lt; 20) &#123; num++; System.out.println(Thread.currentThread().getName() + "开始生产第" + num + "件商品"); notify(); &#125; else &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public synchronized void customer() &#123; if (num &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + "开始消费第" + num + "件商品"); num--; notify(); &#125; else &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;/** * 生产者 */class Product implements Runnable &#123; private Clerk clerk; public Product(Clerk clerk) &#123; this.clerk = clerk; &#125; @Override public void run() &#123; System.out.println("开始生产："); while (true) &#123; clerk.product(); try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;/** * 消费者 */class Customer implements Runnable &#123; private Clerk clerk; public Customer(Clerk clerk) &#123; this.clerk = clerk; &#125; @Override public void run() &#123; System.out.println("开始消费："); while (true) &#123; clerk.customer(); try &#123; Thread.sleep(20); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;public class ProductAndCustomer &#123; public static void main(String[] args) &#123; Clerk clerk = new Clerk(); Thread thread = new Thread(new Customer(clerk)); Thread thread1 = new Thread(new Product(clerk)); thread.setName("消费者"); thread1.setName("生产者"); thread.start(); thread1.start(); &#125;&#125; 该段代码实现原理基本与交替打印类似，不再详述。]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Java多线程之synchronized]]></title>
    <url>%2F2019%2F06%2F02%2Fmultithreading-03%2F</url>
    <content type="text"><![CDATA[线程安全问题提到多线程，就不得不提线程安全问题。线程安全问题发生的首要因素就是，多个线程操作共享变量。只有在操作共享变量时才可能出现线程安全问题，对于局部变量的操作，是不会导致线程安全问题的。 注：本篇文章只讨论线程争抢导致数据不一致问题，不讨论原子性、可见性等问题。示例代码：123456789101112131415161718192021222324252627282930313233343536373839package com.example.socket.multithreading;public class SafetyThread &#123; private static int num = 0; public static void main(String[] args) &#123; Thread thread1 = new Thread(() -&gt; &#123; while (num &lt; 100) &#123; System.out.println(Thread.currentThread().getName() + ":" + num); num++; &#125; &#125;);Thread thread2 = new Thread(() -&gt; &#123; while (num &lt; 100) &#123; System.out.println(Thread.currentThread().getName() + ":" + num); num++; &#125; &#125;); // 存在线程安全问题 thread1.start(); thread2.start(); Thread thread3 = new Thread(() -&gt; &#123; int num = 0; while (num &lt; 100) &#123; System.out.println(Thread.currentThread().getName() + ":" + num); num++; &#125; &#125;);Thread thread4 = new Thread(() -&gt; &#123; int num = 10; while (num &lt; 100) &#123; System.out.println(Thread.currentThread().getName() + ":" + num); num++; &#125; &#125;); // 不存在线程安全问题 thread3.start(); thread4.start(); &#125;&#125; synchronized是什么？synchronized是Java当中的一种同步锁，使用synchronized锁住的代码块都是同步方法 如何使用synchronized解决线程安全问题一下代码均取自初识Java多线程之创建多线程的几种方式(一)中的代码只修改了其中的run方法。 用synchronized解决实现Runnable接口的线程安全问题 锁住整个run方法 123456789101112@Overridepublic synchronized void run() &#123; while (num &gt; 0) &#123; try &#123; Thread.sleep(50); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "当前票号：" + num); num--; &#125;&#125; 锁住this 123456789@Overridepublic void run() &#123; synchronized (this) &#123; while (num &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + "当前票号：" + num); num--; &#125; &#125;&#125; 锁住一个对象 1234567891011private Object obj = new Object();@Overridepublic void run() &#123; synchronized (obj) &#123; while (num &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + "当前票号：" + num); num--; &#125; &#125;&#125; 锁住当前类 123456789@Overridepublic void run() &#123; synchronized (RunnableImpl.class) &#123; while (num &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + "当前票号：" + num); num--; &#125; &#125;&#125; 用synchronized解决继承Thread类的线程安全问题 锁住一个静态方法注：必须将synchronized加在静态方法上，防止run或者非静态方法上都是无效的，因为此时的锁不是同一个对象 1234567891011@Overridepublic void run() &#123; show();&#125;public synchronized static void show() &#123; while (num &gt; 0) &#123; System.out.println(currentThread().getName() + "当前票号：" + num); num--; &#125;&#125; 锁静态对象注：该对象必须是静态的，原因同1 1234567891011private static Object object = new Object();@Overridepublic void run() &#123; synchronized (object) &#123; while (num &gt; 0) &#123; System.out.println(currentThread().getName() + "当前票号：" + num); num--; &#125; &#125;&#125; 锁住当前类 123456789@Overridepublic void run() &#123; synchronized (ExtendThread.class) &#123; while (num &gt; 0) &#123; System.out.println(currentThread().getName() + "当前票号：" + num); num--; &#125; &#125;&#125; 对于继承Thread的线程不能通过锁this来保证线程安全，因为此时的this不是同一对象。 synchronized解惑synchronized锁对象的要求是什么？synchronized锁住的对象，对于多个线程来说必须是同一对象，换言之，多个线程必须使用同一把锁。若多个线程使用不同的锁，将不能保证线程安全问题 将synchronized加在方法上时锁住的到底是什么？synchronized加在普通方法上时，锁住的是当前的this。加在静态方法上时锁住的是当前类 synchronized缺陷synchronized会导致所有方法都是同步执行的对效率有一定影响，所以要控制好锁力度，能锁部分方法体就锁部分方法体，不要锁住整个方法。对于不会发生线程安全的代码块不要随意加锁。]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Java多线程之多线程中的常用方法]]></title>
    <url>%2F2019%2F06%2F02%2Fmultithreading-02%2F</url>
    <content type="text"><![CDATA[多线程中的常用方法 start() 启动当前线程，并调用当前线程的run方法 run() 重写Thread或Runnable的run，供系统调用，不得手动调用 currentThread() Thread中的静态方法，获取当前线程 getName() 获取当前线程的名称 setName() 设置当前线程的名称 yield() 释放当前CPU的执行权 join() 当线程a调用线程b的join方法，线程a就进入阻塞状态，直至线程b执行结束。 stop() 已过时，强制结束当前线程 sleep(long time) 使当前线程进入睡眠状态，time为睡眠的毫秒数。睡眠时线程处于阻塞状态 isAlive() 判断当前线程是否存活 下面我们来着重说明一下 yield(), join() 两个方法，其他方法都是字面意思不再另外说明 yield当线程a调用yield方法是会让出CPU执行权，此时线程a和线程b重新开始CPU执行权争抢，谁抢到谁执行。yield不保证线程b一定能够抢到CPU执行权，可能还是线程a在执行示例代码：1234567891011121314151617181920212223242526272829package com.example.socket.multithreading;/** * 当线程a调用yield方法是会让出CPU执行权，此时线程a和线程b重新开始CPU执行权争抢，谁抢到谁执行。 * yield不保证线程b一定能够抢到CPU执行权，可能还是线程a在执行 * 注：该段代码必须在jdk1.8及以上版本才能运行 */public class YieldThread &#123; public static void main(String[] args) &#123; // lambda表达式 Thread thread = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName() + ":" + i); if (i == 20) &#123; Thread.yield(); &#125; &#125; &#125;); Thread thread1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName() + ":" + i); &#125; &#125;); thread.start(); thread1.start(); &#125;&#125; join当线程a调用线程b的join方法，线程a就进入阻塞状态，直至线程b执行结束，线程a再执行。123456789101112131415161718192021222324252627282930package com.example.socket.multithreading;/** * 当线程a调用线程b的join方法，线程a就进入阻塞状态，直至线程b执行结束，线程a再执行。 */public class JoinThread &#123; public static void main(String[] args) &#123; Thread thread = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName() + ":" + i); &#125; &#125;); Thread thread1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName() + ":" + i); if (i == 20) &#123; try &#123; thread.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;); thread.start(); thread1.start(); &#125;&#125;]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Java多线程之创建多线程的几种方式(一)]]></title>
    <url>%2F2019%2F06%2F02%2Fmultithreading-01%2F</url>
    <content type="text"><![CDATA[前言个人认为多线程属于java的中高级知识，是java当中的重点。也是面试中的几大难点之一。作为初学者往往搞不明白多线程。我个人对多线程也没有太深入的认识，所以这几天也在看多线程相关的知识。在此记录下来以供学习参考。 创建多线程的两种方式虽然标题是创建多线程的两种方式，但实际上创建多线程的方式不止两种。本篇文章暂时说两种简单常见的。其他创建方式将在后续文章补充。 本篇文章中的代码都不是线程安全的，仅供参考。 继承Thread类我们只需要继承Thread类，然后实现其中的run方法即可。使用时只需new出Thread实现对象，然后调用start方法即可示例代码：123456789101112131415161718192021222324252627282930package com.example.socket.multithreading;/** * 创建多线程方式一：继承Thread类 */public class ExtendThread extends Thread &#123; private static int num = 100; @Override public void run() &#123; while (num &gt; 0) &#123; System.out.println(currentThread().getName() + "当前票号：" + num); num--; &#125; &#125; public static void main(String[] args) &#123; Thread extendThread1 = new ExtendThread(); Thread extendThread2 = new ExtendThread(); Thread extendThread3 = new ExtendThread(); // 注意要调用start方法而不是run方法 // 错误 // extendThread1.run(); // 正确 extendThread1.start(); extendThread2.start(); extendThread3.start(); &#125;&#125; 实现Runnable接口与继承Thread类基本一致，都是实现run方法，然后调用start方法启动线程。示例代码：1234567891011121314151617181920212223242526272829package com.example.socket.multithreading;/** * 创建多线程方式二：实现Runnable接口方式 */public class RunnableImpl implements Runnable &#123; private int num = 100; @Override public void run() &#123; while (num &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + "当前票号：" + num); num--; &#125; &#125; public static void main(String[] args) &#123; // 创建Runnable实现类 Runnable runnable = new RunnableImpl(); // 放入Thread的构造器中 Thread thread1 = new Thread(runnable); Thread thread2 = new Thread(runnable); Thread thread3 = new Thread(runnable); thread1.start(); thread2.start(); thread3.start(); &#125;&#125; 两种创建多线程方式应该选用哪种？个人倾向于选择实现Runnable的方式。因为Java只能单继承，一旦继承了Thread类就不能继承其他父类了。但是Java可以实现多个接口，所以实现Runnable接口不影响程序可扩展性。 透过现象看本质我们都知道调用start启动一个线程之后，最终会执行该线程的run方法。在继承Thread类的时候，由于我们实现了run方法，所以启动线程，最终会调用子类当中的run方法。但是我们实现Runnable接口并没有显式或隐式的继承Thread，那么我们的run方法是怎么被调用的呢？通过看Thread的源码可以发现，Thread也实现了Runnable接口，当中也有一个run方法。在我们start的时候调用的其实是Thread中的run方法。以下是该方法的实现。123456@Overridepublic void run() &#123; if (target != null) &#123; target.run(); &#125;&#125; 我们发现在target不为null的情况下会调用target的run方法，那么这个target是谁呢？这个target就是我们传入Thread构造器的Runnable的实现类123public Thread(Runnable target) &#123; init(null, target, "Thread-" + nextThreadNum(), 0);&#125; 所以虽然我们并没有显式或隐式的继承Thread但是最终调用的还是我们自己实现的run方法。 线程的生命周期]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中的socket(01)]]></title>
    <url>%2F2019%2F06%2F01%2Fjava-socket-01%2F</url>
    <content type="text"><![CDATA[学习socket的起因原因就是工作中有个项目要用到socket，第一次听到socket这个词的时候一脸懵逼，java中还有这玩意？不都是SSM一套用HTTP请求吗？怎么还有socket这个玩意？ socket是什么？摘自百度百科: 网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。 才疏学浅，个人没办法明确描述socket是什么。不过定义不重要，重要的是如何使用它。 如何使用socket？创建socket服务端服务端多线程处理客户端请求123456789101112131415161718192021222324252627282930313233343536373839/** * 该类为多线程类，用于服务端 */ public class ServerThread implements Runnable &#123; private Socket client = null; public ServerThread(Socket client)&#123; this.client = client; &#125; @Override public void run() &#123; try&#123; //获取Socket的输出流，用来向客户端发送数据 PrintStream out = new PrintStream(client.getOutputStream()); //获取Socket的输入流，用来接收从客户端发送过来的数据 BufferedReader buf = new BufferedReader(new InputStreamReader(client.getInputStream())); boolean flag =true; while(flag)&#123; //接收从客户端发送过来的数据 String str = buf.readLine(); if(str == null || "".equals(str))&#123; flag = false; &#125;else&#123; if("bye".equals(str))&#123; flag = false; &#125;else&#123; //将接收到的字符串前面加上echo，发送到对应的客户端 out.println("echo:" + str); &#125; &#125; &#125; out.close(); client.close(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125; 开启服务端12345678910111213141516public class Server1 &#123; public static void main(String[] args) throws Exception&#123; //服务端在20006端口监听客户端请求的TCP连接 ServerSocket server = new ServerSocket(20006); Socket client = null; boolean f = true; while(f)&#123; //等待客户端的连接，如果没有获取连接 client = server.accept(); System.out.println("与客户端连接成功！"); //为每个客户端连接开启一个线程 new Thread(new ServerThread(client)).start(); &#125; server.close(); &#125; &#125; 编写socket客户端123456789101112131415161718192021222324252627282930313233343536public class Client1 &#123; public static void main(String[] args) throws IOException &#123; //客户端请求与本机在20006端口建立TCP连接 Socket client = new Socket("127.0.0.1", 20006); client.setSoTimeout(10000); //获取键盘输入 BufferedReader input = new BufferedReader(new InputStreamReader(System.in)); //获取Socket的输出流，用来发送数据到服务端 PrintStream out = new PrintStream(client.getOutputStream()); //获取Socket的输入流，用来接收从服务端发送过来的数据 BufferedReader buf = new BufferedReader(new InputStreamReader(client.getInputStream())); boolean flag = true; while(flag)&#123; System.out.print("输入信息："); String str = input.readLine(); //发送数据到服务端 out.println(str); if("bye".equals(str))&#123; flag = false; &#125;else&#123; try&#123; //从服务器端接收数据有个时间限制（系统自设，也可以自己设置），超过了这个时间，便会抛出该异常 String echo = buf.readLine(); System.out.println(echo); &#125;catch(SocketTimeoutException e)&#123; System.out.println("Time out, No response"); &#125; &#125; &#125; input.close(); if(client != null)&#123; //如果构造函数建立起了连接，则关闭套接字，如果没有建立起连接，自然不用关闭 client.close(); //只关闭socket，其关联的输入输出流也会被关闭 &#125; &#125; &#125; 使用socket的个人体会 写出一个简单的服务端/客户端Demo很容易，实际使用并不简单 socket和HTTP不同，HTTP有请求就有响应，而socket可以没有响应。又或者说socket根本就没有响应这个概念。因为socket是全双工的，所以它的请求和响应都一样。这就需要在使用过程中分辨请求和响应。 socket必须要鉴权，在第一次使用socket的时候我就在想，这不是只要我开放了端口谁都可以连接上我的socket服务端吗？所以用socket一定要鉴权，对非法连接拒之门外（虽然我不知道的怎么做，但是一定要做）。 socket读取数据十分麻烦，TCP/IP是传输层协议，而HTTP是应用层协议，两者分工不同。自然造就就读取数据的差异。使用socket必须事事亲力亲为，否则什么都办不成。 参考链接java tcp socket编程TCP/IP和socket的关系TCP/IP和HTTP协议的区别]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>socket</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[electron与vue配合生成客户端]]></title>
    <url>%2F2019%2F05%2F26%2Felectron-vue-01%2F</url>
    <content type="text"><![CDATA[electron是什么？官网描述：如果你可以建一个网站，你就可以建一个桌面应用程序。 Electron 是一个使用 JavaScript, HTML 和 CSS 等 Web 技术创建原生程序的框架，它负责比较难搞的部分，你只需把精力放在你的应用的核心上即可。 如何与vue搭配使用？ 首先我们需要创建一个vue项目 安装electron，推荐使用全局安装，不然编译的时候比较麻烦。 npm install -g electron 安装electron-builder，和electron采用全局安装方式 npm install -g electron-builder 对vue项目进行打包，我使用的是yarn，用npm同理 yarn build 进入打包好的dist文件夹，新建main.js和package.json两个文件 main.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// Modules to control application life and create native browser windowconst &#123; app, BrowserWindow &#125; = require('electron')// const isDev = require('electron-is-dev');// const path = require('path');// Keep a global reference of the window object, if you don't, the window will// be closed automatically when the JavaScript object is garbage collected.let mainWindowfunction createWindow() &#123; // Create the browser window. mainWindow = new BrowserWindow(&#123; width: 800, height: 600, webPreferences: &#123; nodeIntegration: true &#125; &#125;) // and load the index.html of the app. // mainWindow.loadURL(url.format(&#123; // pathname: path.join(__dirname, './build/index.html'), // protocol: 'file:', // slashes: true // &#125;)) // const devUrl = 'http://localhost:3000'; // 本地文件路径定位到打包的react文件 const localUrl = `file://$&#123;__dirname&#125;/index.html`; // const appUrl = isDev ? devUrl : localUrl; mainWindow.loadURL(localUrl) // Open the DevTools. // mainWindow.webContents.openDevTools() // Emitted when the window is closed. mainWindow.on('closed', function () &#123; // Dereference the window object, usually you would store windows // in an array if your app supports multi windows, this is the time // when you should delete the corresponding element. mainWindow = null &#125;)&#125;// This method will be called when Electron has finished// initialization and is ready to create browser windows.// Some APIs can only be used after this event occurs.app.on('ready', createWindow)// Quit when all windows are closed.app.on('window-all-closed', function () &#123; // On macOS it is common for applications and their menu bar // to stay active until the user quits explicitly with Cmd + Q if (process.platform !== 'darwin') app.quit()&#125;)app.on('activate', function () &#123; // On macOS it's common to re-create a window in the app when the // dock icon is clicked and there are no other windows open. if (mainWindow === null) createWindow()&#125;)// In this file you can include the rest of your app's specific main process// code. You can also put them in separate files and require them here. package.json1234567891011121314151617&#123; "name": "hello", "productName": "test-electron", "version": "0.1.0", "main": "main.js", "scripts": &#123; "dist": "electron-builder" &#125;, "build": &#123; "directories": &#123; "output": "../test" &#125; &#125;, "nsis": &#123; "oneClick": false &#125;&#125; 最后一步，对electron进行打包，第一次打包时间可能会比较久，因为要下载一下依赖，由于众所周知的原因还可能下载失败，耐心等待一下。 yarn dist 可能出现的问题执行yarn dist下载依赖失败解决办法: 手动下载electron相关依赖，然后放到（不需要解压） C:\Users***\AppData\Local\electron\Cache 手动下载electron-builde相关依赖，然后放到（需要解压） C:\Users***\AppData\Local\electron-builder\Cache 依赖下载成功后打包依然失败将electron-builder中的winCodeSign的所有Plugin复制到nsis当中 参考链接React + Electron 搭建一个桌面应用正确设置 ELECTRON_MIRROR ，加速下载 electron 预编译文件Electron 应用如何利用 create-react-app 从 0 到 1Electron 打包问题：electron-builder 下载各种依赖出错electron 构建打包总结Windows 10 build Error (NSIS)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>electron</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud(2)--服务发现和注册Eureka]]></title>
    <url>%2F2019%2F03%2F04%2Fspring-cloud-eureka%2F</url>
    <content type="text"><![CDATA[概念 服务注册 Eureka Client向Eureka Server注册 服务续约 Eureka Client默认情况下每30秒发送一次心跳来进行服务续约 获取服务注册列表信息 客户端向服务端获取服务注册信息，并将其缓存在本地，每30秒更新一次。如果由于某些原因导致注册信息不能及时匹配，客户端会重新获取整个注册表信息。可使用xml和json通信，默认以json通信。 服务下线 客户端关闭时可向服务端发送下线请求，该请求不会自动完成，需要手动调用如下代码： 注：DiscoveryManager在使用Spring Cloud Greenwich.RELEASE版本时发现为已过时的，具体替代类由于个人实力有限，暂时还不清楚 1DiscoveryManager.getInstance().shutdownComponent(); 服务剔除 在默认情况下，当客户端90秒没有向服务端发送心跳，服务端会将该客户端从注册表中移除 创建Maven主工程由于本案例有多个Spring Boot工程，为了方便管理，采用Maven多Module结构 更改Type首先我们通过idea创建一个Spring Boot工程，将其中的Type由Maven Project更改为Maven POM 修改pom文件创建好spring boot工程后将pom文件做如下修改： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;modules&gt; &lt;module&gt;eureka-server&lt;/module&gt; &lt;module&gt;eureka-client&lt;/module&gt; &lt;/modules&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.3.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.yhzl.cloud&lt;/groupId&gt; &lt;artifactId&gt;test&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;name&gt;test&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Greenwich.RELEASE&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;/project&gt; 创建Eureka Server创建Module在主工程下新增一个Module，名称叫做eureka-server 修改pom文件123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.yhzl.cloud&lt;/groupId&gt; &lt;artifactId&gt;test&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;eureka-server&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;eureka-server&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 修改yml文件1234567891011server: port: 8081eureka: instance: hostname: localhost client: register-with-eureka: false fetch-registry: false service-url: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ 修改EurekaServerApplication文件123456789101112131415package com.yhzl.cloud.eurekaserver;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;@EnableEurekaServer@SpringBootApplicationpublic class EurekaServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaServerApplication.class, args); &#125;&#125; 创建Eureka Client 创建步骤与Eureka Server一致 修改yml文件12345678910eureka: client: service-url: defaultZone: http://localhost:8081/eureka/server: port: 8082spring: application: name: eureka-client 修改EurekaClientApplication文件123456789101112131415package com.yhzl.cloud.eurekaclient;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;@EnableEurekaClient@SpringBootApplicationpublic class EurekaClientApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaClientApplication.class, args); &#125;&#125; 启动项目 构建高可用Eureka Server集群修改Eureka Server的yml文件1234567891011121314151617181920212223242526spring: profiles: peer1 application: name: peer1server: port: 8081eureka: instance: hostname: peer1 client: service-url: defaultZone: http://peer2:8082/eureka/---spring: profiles: peer2 application: name: peer2server: port: 8082eureka: instance: hostname: peer2 client: service-url: defaultZone: http://peer1:8081/eureka/ 配置Windows的hosts 首先以管理员权限打开记事本，然后找到hosts文件，默认是在该路径下 C:\Windows\System32\drivers\etc 然后添加两行代码 127.0.0.1 peer1127.0.0.1 peer2 配置idea参数启动找到Run Dashboard 配置启动项peer1配置参考 peer2配置类似，只需将图中的peer1修改为peer2即可 修改eureka client的yml文件12345678910eureka: client: service-url: defaultZone: http://peer1:8081/eureka/server: port: 8083spring: application: name: eureka-client 该配置文件的意思是，仅向peer1注册服务。 最后运行三个服务，会发现，虽然eureka client仅向peer1注册了服务，但是会自动同步到peer2上 Eureka自我保护机制 默认情况下，如果eureka server在15分钟之内接收到的服务续约率低于85%，那么eureka将会开启自我保护模式，这是为了防止当eureka注册中心自己网络出现故障时，导致了可用的eureka client被意外删除。默认情况下eureka的自我保护机制是开启的，如需关闭，可以在配置文件中添加如下代码 123eureka: server: enable-self-preservation: false 自我保护模式推荐开启，这样可以防止当注册中心网络故障时导致的有效服务不可用。 当然自我保护模式也有坏处，默认情况下服务续约总数=服务总数*2。当服务总数过低时(低于7个)，会导致真正的服务宕机eureka也会开启自我保护模式，因为服务续约率会低于百分之85.]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>spring cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud(1)--初识spring cloud]]></title>
    <url>%2F2019%2F03%2F04%2Fspring-cloud-start%2F</url>
    <content type="text"><![CDATA[简介Spring Cloud提供了开发分布式微服务系统的一些常用组件，例如服务注册和发现、配置中心、熔断器、智能路由、微代理、控制总线、全局锁、分布式会话等。 常用组件 服务注册和发现组件Eureka 可以轻松的实现服务注册与发现功能，另外Spring Cloud 也支持Consul和Zookeeper，用于服务注册与发现 熔断组件Hystrix 除了基本的熔断器功能，还能实现服务降级、服务限流的功能 负载均衡组件Ribbon 通常和Eureka、Zuul、RestTemplate、Feign配合使用。Ribbon和Zuul配合，很容易实现负载均衡；Ribbon和RestTemplate、Feign配合，在消费服务时能够做到负载均衡。 路由网关Zuul Zuul有智能路由和过滤的功能 上述四个组件都来自Netflix的公司，统称为Spring Cloud Netflix Spring Cloud Config 提供了配置文件统一管理的功能，包括Server端和Client端，Server端读取本地仓库或远程仓库的配置文件，Client向Server端读取配置信息 Spring Cloud Sleuth 分布式链路追踪组件]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>spring cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习docker中遇到的问题]]></title>
    <url>%2F2018%2F08%2F03%2Fdocker-error%2F</url>
    <content type="text"><![CDATA[yaml: line 1: mapping values are not allowed in this context按照官网入门教程的第三部分执行到docker stack deploy -c docker-compose.yml getstartedlab，会出现这个错误，那是因为yaml的语法格式有问题，部分地方少了空格补上就好。yml在线错误校验https://www.bejson.com/validators/yaml/参考博客：https://blog.csdn.net/kuangay/article/details/80662914]]></content>
      <categories>
        <category>容器</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux下java的安装]]></title>
    <url>%2F2018%2F07%2F16%2Flinux-java-install%2F</url>
    <content type="text"><![CDATA[Linux下java的安装基本环境Linux: CentOS Linux release 7.5.1804 (Core)Java: java version “10.0.1” 下载java首先进入oracle官网找到你需要下载的java版本:http://www.oracle.com/technetwork/java/javase/downloads/index.html我这里一jdk10为例，在linux下执行以下命令即可下载: wget http://download.oracle.com/otn-pub/java/jdk/10.0.1+10/fb4372174a714e6b8c52526dc134031e/jdk-10.0.1_linux-x64_bin.tar.gz 如果提示wget未找到命令则执行: yum install wget -ywget http://download.oracle.com/otn-pub/java/jdk/10.0.1+10/fb4372174a714e6b8c52526dc134031e/jdk-10.0.1_linux-x64_bin.tar.gz 解压javatar xzvf jdk-10.0.1_linux-x64_bin.tar.gz 配置环境变量打开profile vi /etc/profile 按i编辑,在文件末尾加上 export JAVA_HOME=jdk-10.0.1export PATH=$JAVA_HOME/bin:$PATH 首先按esc退出insert模式，然后输入##:wq##保存文件最后执行: source /etc/profile 测试配置是否生效输入: java -version 输出： [root@localhost /]# java -versionjava version “10.0.1” 2018-04-17Java(TM) SE Runtime Environment 18.3 (build 10.0.1+10)Java HotSpot(TM) 64-Bit Server VM 18.3 (build 10.0.1+10, mixed mode)]]></content>
      <tags>
        <tag>java</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring注解-注册bean的几种方式]]></title>
    <url>%2F2018%2F07%2F11%2Fspring-annotation03%2F</url>
    <content type="text"><![CDATA[前言在spring中注册bean有多种方式： 包扫描+组件标注注解（@Controller/@Service/@Repository/@Component）[自己写的类] @Bean[导入的第三方包里面的组件] @Import[快速给容器中导入一个组件] @Import(要导入到容器中的组件)；容器中就会自动注册这个组件，id默认是全类名 ImportSelector:返回需要导入的组件的全类名数组； ImportBeanDefinitionRegistrar:手动注册bean到容器中 使用Spring提供的 FactoryBean（工厂Bean）; 默认获取到的是工厂bean调用getObject创建的对象 要获取工厂Bean本身，我们需要给id前面加一个&amp; 包扫描与@Bean注解前面章节中已经提过不再概述 @Import注解基本使用@Import( {类名.class} )例：@Import( {Color.class,Red.class} ) ImportSelectorImportSelector是@Import的一个参数，该注解在spring boot中大量使用，使用ImportSelector，首先要实现ImportSelector接口1234567891011121314//自定义逻辑返回需要导入的组件public class MyImportSelector implements ImportSelector &#123; //返回值，就是到导入到容器中的组件全类名 //AnnotationMetadata:当前标注@Import注解的类的所有注解信息 @Override public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123; // TODO Auto-generated method stub //importingClassMetadata //方法不要返回null值 return new String[]&#123;"com.yhzl.bean.Blue","com.yhzl.bean.Yellow"&#125;; &#125;&#125; 使用方法： @Import( {MyImportSelector.class} ) ImportBeanDefinitionRegistrar实现ImportBeanDefinitionRegistrar接口：1234567891011121314151617181920212223public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar &#123; /** * AnnotationMetadata：当前类的注解信息 * BeanDefinitionRegistry:BeanDefinition注册类； * 把所有需要添加到容器中的bean；调用 * BeanDefinitionRegistry.registerBeanDefinition手工注册进来 */ @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123; boolean definition = registry.containsBeanDefinition("com.yhzl.bean.Red"); boolean definition2 = registry.containsBeanDefinition("com.yhzl.bean.Blue"); //当Red和Blue都被spring注册时，将注册RainBow if(definition &amp;&amp; definition2)&#123; //指定Bean定义信息；（Bean的类型，Bean。。。） RootBeanDefinition beanDefinition = new RootBeanDefinition(RainBow.class); //注册一个Bean，指定bean名 registry.registerBeanDefinition("rainBow", beanDefinition); &#125; &#125;&#125; 使用方法： @Import( {MyImportBeanDefinitionRegistrar.class} ) FactoryBean使用FactoryBean，首先要实现spring的org.springframework.beans.factory.FactoryBean接口12345678910111213141516171819202122232425262728293031package com.atguigu.bean;import org.springframework.beans.factory.FactoryBean;//创建一个Spring定义的FactoryBeanpublic class ColorFactoryBean implements FactoryBean&lt;Color&gt; &#123; //返回一个Color对象，这个对象会添加到容器中 @Override public Color getObject() throws Exception &#123; // TODO Auto-generated method stub System.out.println("ColorFactoryBean...getObject..."); return new Color(); &#125; @Override public Class&lt;?&gt; getObjectType() &#123; // TODO Auto-generated method stub return Color.class; &#125; //是单例？ //true：这个bean是单实例，在容器中保存一份 //false：多实例，每次获取都会创建一个新的bean； @Override public boolean isSingleton() &#123; // TODO Auto-generated method stub return false; &#125;&#125; 配置类：123456// 注：该方法返回的的是FactoryBean的getObject()方法所返回的对象，并发工厂本身// 若有想获取工厂本身在获取时需要加上&amp;@Beanpublic ColorFactoryBean colorFactoryBean()&#123; return new ColorFactoryBean();&#125;]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring注解(1)]]></title>
    <url>%2F2018%2F07%2F11%2Fspring-annotation02%2F</url>
    <content type="text"><![CDATA[@ComponentScan@ComponentScan使用@Repeatable标识，在jdk1.8中可重复标注，在1.8以下版本中可使用@ComponentScans达到同样效果 value@ComponentScan value:指定要扫描的包 例：@ComponentScan(value = “com.yhzl”) excludeFilters和includeFiltersexcludeFilters = Filter[] ：指定扫描的时候按照什么规则排除那些组件includeFilters = Filter[] ：指定扫描的时候只需要包含哪些组件 例：includeFilters = { @Filter(type = FilterType.ANNOTATION, classes = { Controller.class }) } 参数typeFilterType.ANNOTATION：按照注解FilterType.ASSIGNABLE_TYPE：按照给定的类型FilterType.ASPECTJ：使用ASPECTJ表达式FilterType.REGEX：使用正则指定FilterType.CUSTOM：使用自定义规则 自定义过滤规则自定义过滤规则需要实现TypeFilter接口首先在配置类的excludeFilters或includeFilters中标注 @Filter(type=FilterType.CUSTOM,classes={类名.class}) 实现TypeFilter接口12345678910111213141516171819202122232425262728293031323334353637package com.yhzl.config;import java.io.IOException;import org.springframework.core.io.Resource;import org.springframework.core.type.AnnotationMetadata;import org.springframework.core.type.ClassMetadata;import org.springframework.core.type.classreading.MetadataReader;import org.springframework.core.type.classreading.MetadataReaderFactory;import org.springframework.core.type.filter.TypeFilter;public class MyTypeFilter implements TypeFilter &#123; /** * metadataReader：读取到的当前正在扫描的类的信息 * metadataReaderFactory:可以获取到其他任何类信息的 */ @Override public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException &#123; // TODO Auto-generated method stub //获取当前类注解的信息 AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata(); //获取当前正在扫描的类的类信息 ClassMetadata classMetadata = metadataReader.getClassMetadata(); //获取当前类资源（类的路径） Resource resource = metadataReader.getResource(); //获取类名 String className = classMetadata.getClassName(); System.out.println("---&gt;"+className); if(className.contains("er"))&#123; return true; &#125; return false; &#125;&#125; @Scope@Scope:调整作用域，默认值为：singletonprototype：多实例的：ioc容器启动并不会去调用方法创建对象放在容器中。每次获取的时候才会调用方法创建对象；singleton：单实例的（默认值）：ioc容器启动会调用方法创建对象放到ioc容器中。以后每次获取就是直接从容器（map.get()）中拿，request：同一次请求创建一个实例session：同一个session创建一个实例 @Lazy懒加载：单实例bean：默认在容器启动的时候创建对象；懒加载：容器启动不创建对象。第一次使用(获取)Bean创建对象，并初始化； @Conditional@Conditional按条件注册bean，既可标注在类上也可标注在方法上，参数为Condition的实现类Condition的实现类12345678910111213141516171819202122232425262728293031323334353637383940package com.yhzl.condition;import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;import org.springframework.beans.factory.support.BeanDefinitionRegistry;import org.springframework.context.annotation.Condition;import org.springframework.context.annotation.ConditionContext;import org.springframework.core.env.Environment;import org.springframework.core.type.AnnotatedTypeMetadata;//判断是否linux系统public class LinuxCondition implements Condition &#123; /** * ConditionContext：判断条件能使用的上下文（环境） * AnnotatedTypeMetadata：注释信息 */ @Override public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123; // TODO是否linux系统 //1、能获取到ioc使用的beanfactory ConfigurableListableBeanFactory beanFactory = context.getBeanFactory(); //2、获取类加载器 ClassLoader classLoader = context.getClassLoader(); //3、获取当前环境信息 Environment environment = context.getEnvironment(); //4、获取到bean定义的注册类 BeanDefinitionRegistry registry = context.getRegistry(); //获取当前系统名称 String property = environment.getProperty("os.name"); //可以判断容器中的bean注册情况，也可以给容器中注册bean boolean definition = registry.containsBeanDefinition("person"); if(property.contains("linux"))&#123; return true; &#125; return false; &#125;&#125; 配置类12345@Conditional(LinuxCondition.class) @Bean("linus") public Person person02()&#123; return new Person("linus", 48); &#125;]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring注解-Hello World]]></title>
    <url>%2F2018%2F07%2F10%2Fspring-annotation01%2F</url>
    <content type="text"><![CDATA[使用java类代替传统的xml传统配置 1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.3.xsd"&gt; &lt;bean id="person" class="com.yhzl.bean.Person" scope="prototype" &gt; &lt;property name="age" value="18"&gt;&lt;/property&gt; &lt;property name="name" value="zhangsan"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; java配置类1234567891011//配置类==配置文件@Configurationpublic class MainConfig &#123; //给容器中注册一个Bean;类型为返回值的类型，id默认是用方法名作为id @Bean("person") public Person person01()&#123; return new Person("lisi", 20); &#125;&#125; 实体类12345678910111213141516171819202122232425262728293031323334353637public class Person &#123; private String name; private Integer age; private String nickName; public String getNickName() &#123; return nickName; &#125; public void setNickName(String nickName) &#123; this.nickName = nickName; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public Person(String name, Integer age) &#123; super(); this.name = name; this.age = age; &#125; public Person() &#123; super(); // TODO Auto-generated constructor stub &#125; @Override public String toString() &#123; return "Person [name=" + name + ", age=" + age + ", nickName=" + nickName + "]"; &#125; 测试类1234567891011121314151617181920public class MainTest &#123; public static void main(String[] args) &#123;// 传统方式// ApplicationContext applicationContext = new ClassPathXmlApplicationContext("beans.xml");// Person bean = (Person) applicationContext.getBean("person");// System.out.println(bean); ApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig.class); Person bean = applicationContext.getBean(Person.class); System.out.println(bean); // 通过类型获取beanName String[] namesForType = applicationContext.getBeanNamesForType(Person.class); for (String name : namesForType) &#123; System.out.println(name); &#125; &#125;&#125; 注解说明@Configuration 告诉Spring这是一个配置类 @Bean 等同于传统xml的标签，id默认为方法名，若想改变id可给@Bean注解传入参数，如：@Bean(“person”)]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下nginx的安装]]></title>
    <url>%2F2018%2F07%2F06%2Fnginx01%2F</url>
    <content type="text"><![CDATA[遇到的问题the HTTP rewrite module requires the PCRE library error: the HTTP rewrite module requires the PCRE library.You can either disable the module by using –without-http_rewrite_moduleoption, or install the PCRE library into the system, or build the PCRE librarystatically from the source with nginx by using –with-pcre= option. 解决方案： yum -y install pcre-devel the HTTP gzip module requires the zlib library error: the HTTP gzip module requires the zlib library.You can either disable the module by using –without-http_gzip_moduleoption, or install the zlib library into the system, or build the zlib librarystatically from the source with nginx by using –with-zlib= option. 解决方案： yum install -y zlib-devel C compiler cc is not found原因： 缺少 gcc-c++ 的包 解决方案： yum -y install gcc-c++ nginx的下载及安装官网12345678910// 下载wget http://nginx.org/download/nginx-1.14.0.tar.gz// 解压tar xzvf nginx-1.14.0.tar.gz// 进入 nginx-1.14.0目录cd nginx-1.14.0// 安装./configuremakemake install 启动nginx进入安装目录，默认为/usr/local/nginx ./sbin/nginx 停止nginx nginx -s stop 重启nginx nginx -s reload]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[连接redis]]></title>
    <url>%2F2018%2F06%2F28%2Fredis01%2F</url>
    <content type="text"><![CDATA[遇到的问题无法连接上redis使用redis-cli可以正常使用redis，但是在Windows中使用python连不上，这就很烦躁，没办法只能靠百度了1.可能是端口未开放使用该命令开放端口1firewall-cmd --zone=public --add-port=6379/tcp --permanent 2.修改redis.conf配置 将bind 127.0.0.1 改为 bind 0.0.0.0将protected-mode yes 改为 protected-mode no 安装python的redis模块 pip install redis python连接redis12345import redisconn = redis.StrictRedis(host='ip地址', password='密码')conn.set('test', 'test1')print(conn.get('test')) java连接redispom.xml12345678&lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; java代码1234567891011121314package com.yhzl.dao01.redis;import redis.clients.jedis.Jedis;public class RedisDay01 &#123; public static void main(String[] args) &#123; Jedis jedis = new Jedis("ip地址"); jedis.auth("密码"); jedis.set("test1", "test1"); System.out.println(jedis.get("test1")); &#125; &#125; 参考博客虚拟机安装Redis后无法连接问题的处理redis的配置（安装、启动、本机与虚拟机的redis的连接）redis使用密码登录]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>nosql</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下redis的安装]]></title>
    <url>%2F2018%2F06%2F28%2Finstall-redis%2F</url>
    <content type="text"><![CDATA[遇到的问题本次安装redis过程中遇到了不少问题在此一一记录下来！！！ yum出现Could not retrieve mirrorlist出现该问题一般是由于网络有问题，具体解决方案参照https://blog.csdn.net/gebitan505/article/details/54584213 wget未找到命令解决方案：https://blog.csdn.net/djj_alice/article/details/80407769 jemalloc/jemalloc.h：没有那个文件或目录解决方案：https://blog.csdn.net/honchou56/article/details/53994708 make后报错安装gcc，解决方案：https://yq.aliyun.com/articles/238783 版本Linux版本： CentOS Linux release 7.5.1804 (Core)Redis版本： 4.0.10 64位 redis的下载进入该页面https://redis.io/download找到Installation，按照步骤来即可完成安装。 redis的启动 src/redis-server &amp; 注意后面要加一个&amp;，否则ctrl+c会关闭redis，&amp;代表后台运行然后执行 src/redis-cli 即可进入redis]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>nosql</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven]]></title>
    <url>%2F2018%2F05%2F27%2Fmaven%2F</url>
    <content type="text"><![CDATA[官网下载mavenhttps://maven.apache.org/download.cgi 解压并进入conf双击setting.xml将maven中央仓库改为阿里云的，在mirrors节点下添加如下代码123456&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 将jdk版本改为1.8，在profiles节点下添加如下代码123456789101112&lt;profile&gt; &lt;id&gt;jdk18&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;/profile&gt; 配置eclipse找到以下目录 Window-&gt;Preferences-&gt;maven-&gt;User Settings 将User Settings的路径更改为刚刚配置的setting.xml的路径]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zteoa项目]]></title>
    <url>%2F2018%2F05%2F27%2Fteam-zteoa%2F</url>
    <content type="text"><![CDATA[初始化项目项目地址：https://github.com/chsm1998/team_zteoa.git 方法一：使用git clone命令拷贝然后导入eclipse1git clone https://github.com/chsm1998/team_zteoa.git 方法二：首先找到Git Repositories点击之后下方将出现 然后点击出现该框后一直next就好了 拷贝完项目后点击import projects 完成后应该有如下目录 项目要求数据库新建用户 用户名为:three,密码为:team参考链接 注意事项 禁止向leader分支提交代码 禁止修改公共配置文件 禁止改动他人代码，若需要使用接口，请与模块负责人联系，不得直接更改他人模块 每个类需注明编写人、编写时间，对于接口方法需编写注释指明接口作用 其他细则参照团队开发]]></content>
      <categories>
        <category>团队</category>
      </categories>
      <tags>
        <tag>team</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring-mvc的疑惑(持续更新)]]></title>
    <url>%2F2018%2F05%2F12%2Fspring-mvc%2F</url>
    <content type="text"><![CDATA[1.@SessionAttribute注解以下是官方文档的解释： If you need access to pre-existing session attributes that are managed globally, i.e. outside the controller (e.g. by a filter), and may or may not be present use the @SessionAttribute annotation on a method parameter: 关键在于and may or may not be present翻译过来是:可能存在也可能不存在而在实际使用时若session无法获取到该属性是会报400错误的： Missing session attribute ‘user’ of type User 2.@RequestBody关于该注解还是由于自己底层知识不够造成的，昨天在编写代码的过程中发现会报一个Stream close的错误，想尝试Debug发现根本没进入自己写的方法，然后就是各种百度，依旧没找到答案……没办法有bug也得解决啊，既然没进入方法肯定是spring mvc赋值时的问题呗，然后一个一个删参数，发现当参数中有两个@RequestBody时会发生这个错误，后来一想也是一次请求怎么可能会有两个请求体呢？后来的解决方法是利用map结束值，然后再手动赋值给对象]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>spring mvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用mybatis中遇到的一些坑(持续更新)]]></title>
    <url>%2F2018%2F04%2F05%2Fmybatis-error%2F</url>
    <content type="text"><![CDATA[当xxxMapper的方法需要多个参数时，引发的异常方法： User getUser(Integer id, String username); xml配置:123&lt;select id="getUser" resultType="user"&gt; select * from User where id = #&#123;id&#125; and username = #&#123;username&#125;&lt;/select&gt; 此时若调用getUser方法会抛出一个异常： Cause: org.apache.ibatis.binding.BindingException: Parameter ‘id’ not found. Available parameters are [arg1, arg0, param1, param2] 造成原因： 由于mybatis会自动将参数封装成一个map，该map的key默认为param+参数位置，所以此时用id和username取值会报错 解决办法：123&lt;select id="getUser" resultType="user"&gt; select * from User where id = #&#123;param1&#125; and username = #&#123;param2&#125;&lt;/select&gt; 如果非要用#{id}和#{username}怎么办？加上@Param注解1User getUser(@Param("id")Integer id, @Param("username")String username); 当然这种解决办法让人感觉还是很麻烦，有没有简单一点的方式呢？ 直接传入一个pojo对象 例： User getUser(User user); 若没有pojo怎么办？直接传入map 例： User getUser(Map&lt;Object, Object&gt; map);]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>mybatis</tag>
        <tag>error</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis03--xml映射文件]]></title>
    <url>%2F2018%2F04%2F05%2Fmybatis03%2F</url>
    <content type="text"><![CDATA[select使用非常简单：123&lt;select id="selectPerson" parameterType="int" resultType="hashmap"&gt; SELECT * FROM PERSON WHERE ID = #&#123;id&#125;&lt;/select&gt; 下面讲一下其中常用的属性： id 唯一标识符 parameterType 传入的参数类型，该属性是可选的，mybatis会自动推断 resultType 返回值类型，不能与resultMap同时使用 resultMap 外部 resultMap 的命名引用关于resultType和resultMap特别说明一下，官方给出的说明特别简短，具体两者有什么不同到时候在实际使用中再说 insert, update 和 delete与select差不多这里把几个不同的属性说一下: useGeneratedKeys （仅对 insert 和 update 有用）默认值为false，当为true时会从数据库中取出自动增长的主键值，并将值返回 keyProperty （仅对 insert 和 update 有用）MyBatis 会通过 getGeneratedKeys 的返回值或者通过 insert 语句的 selectKey 子元素设置它的键值 例：123456789101112&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="org.mybatis.example.BlogMapper"&gt; &lt;select id="selectUser" resultType="com.yhzl.bean.User"&gt; select * from User where id = #&#123;id&#125; &lt;/select&gt; &lt;insert id="insertUser" useGeneratedKeys="true" keyProperty="id"&gt; insert into User (username, password) values (#&#123;username&#125;, #&#123;password&#125;) &lt;/insert&gt;&lt;/mapper&gt; 12345678910111213141516171819202122232425262728293031323334package com.yhzl.test;import java.io.IOException;import java.io.InputStream;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import com.yhzl.bean.User;/** * @author chsm * @date 2018年4月4日上午8:33:13 * @version 1.0 */public class Test &#123; public static void main(String[] args) throws IOException &#123; InputStream inputStream = Resources.getResourceAsStream("mybatis-config.xml"); SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession session = sessionFactory.openSession(); User user2 = new User(); user2.setUsername("abcdefg"); user2.setPassword("abcdefg"); int i = session.insert("org.mybatis.example.BlogMapper.insertUser", user2); session.commit(); session.close(); //当设置useGeneratedKeys="true" keyProperty="id"时User有id值，若不设置则没有id值 System.out.println(user2); &#125; &#125; sql这个元素可以被用来定义可重用的 SQL 代码段，可以包含在其他语句中。它可以被静态地(在加载参数) 参数化. 不同的属性值通过包含的实例变化. 比如：1&lt;sql id="userColumns"&gt; $&#123;alias&#125;.id,$&#123;alias&#125;.username,$&#123;alias&#125;.password &lt;/sql&gt; 这个 SQL 片段可以被包含在其他语句中，例如：1234567&lt;select id="selectUsers" resultType="map"&gt; select &lt;include refid="userColumns"&gt;&lt;property name="alias" value="t1"/&gt;&lt;/include&gt;, &lt;include refid="userColumns"&gt;&lt;property name="alias" value="t2"/&gt;&lt;/include&gt; from some_table t1 cross join some_table t2&lt;/select&gt; SQL中也可以使用include，例如：1234567891011121314151617&lt;sql id="sometable"&gt; $&#123;prefix&#125;Table&lt;/sql&gt;&lt;sql id="someinclude"&gt; from &lt;include refid="$&#123;include_target&#125;"/&gt;&lt;/sql&gt;&lt;select id="select" resultType="map"&gt; select field1, field2, field3 &lt;include refid="someinclude"&gt; &lt;property name="prefix" value="Some"/&gt; &lt;property name="include_target" value="sometable"/&gt; &lt;/include&gt;&lt;/select&gt; 后面章节对于后面章节推荐大家前往官网观看附上链接：http://www.mybatis.org/mybatis-3/zh/sqlmap-xml.html#Parameters]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis02--xml配置文件]]></title>
    <url>%2F2018%2F04%2F04%2Fmybatis02%2F</url>
    <content type="text"><![CDATA[properties可以用来设置属性1234&lt;properties resource="org/mybatis/example/config.properties"&gt; &lt;property name="username" value="dev_user"/&gt; &lt;property name="password" value="F2Fa3!33TYyg"/&gt;&lt;/properties&gt; 然后就可以使用配置的属性啦123456&lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;driver&#125;"/&gt; &lt;property name="url" value="$&#123;url&#125;"/&gt; &lt;property name="username" value="$&#123;username&#125;"/&gt; &lt;property name="password" value="$&#123;password&#125;"/&gt;&lt;/dataSource&gt; 当然properties也可以由java代码来配置12//传入MyBatis配置文件和属性配置文件SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, props); 如果三者混合使用会出现什么情况呢？这里引用MyBatis官方的解释 在 properties 元素体内指定的属性首先被读取。 然后根据 properties 元素中的 resource 属性读取类路径下属性文件或根据 url 属性指定的路径读取属性文件，并覆盖已读取的同名属性。 最后读取作为方法参数传递的属性，并覆盖已读取的同名属性。 简单的说就是java代码&gt;外部配置&gt;内部配置从MyBatis3.4.2开始可以为占位符指定默认值了，附上官方案例：1234&lt;dataSource type="POOLED"&gt; &lt;!-- 当username不存在时,值就会使用ut_user代替 --&gt; &lt;property name="username" value="$&#123;username:ut_user&#125;"/&gt;&lt;/dataSource&gt; 不过该特性默认情况下是关闭的需手动开启：123&lt;properties resource="org/mybatis/example/config.properties"&gt; &lt;property name="org.apache.ibatis.parsing.PropertyParser.enable-default-value" value="true"/&gt; &lt;!-- Enable this feature --&gt;&lt;/properties&gt; settings该属性比较多，在这里就不详述了，有需要的可以看官方文档:http://www.mybatis.org/mybatis-3/zh/configuration.html#settings typeAliases该属性用于给类设置别名例：12345678&lt;typeAliases&gt; &lt;typeAlias alias="Author" type="domain.blog.Author"/&gt; &lt;typeAlias alias="Blog" type="domain.blog.Blog"/&gt; &lt;typeAlias alias="Comment" type="domain.blog.Comment"/&gt; &lt;typeAlias alias="Post" type="domain.blog.Post"/&gt; &lt;typeAlias alias="Section" type="domain.blog.Section"/&gt; &lt;typeAlias alias="Tag" type="domain.blog.Tag"/&gt;&lt;/typeAliases&gt; 当需要使用某个类时就不需要写包名+类名啦，直接使用别名就可以了还可以指定包名，这样MyBatis就会扫描该包下的所有类，若没加注解标识则默认别名为类名小写123&lt;typeAliases&gt; &lt;package name="domain.blog"/&gt;&lt;/typeAliases&gt; 若有注解，则别名为注解所设定的值1234@Alias("Author")public class Author &#123; ...&#125; 对于typeHandlers、objectFactory、plugins这三个标签我们以后再分析 environments(配置环境)environment在MyBatis中允许配置多个环境例：123456789101112131415161718192021222324&lt;environments default="aaa"&gt; &lt;environment id="aaa"&gt; &lt;transactionManager type="JDBC"&gt; &lt;property name="..." value="..."/&gt; &lt;/transactionManager&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;driver&#125;"/&gt; &lt;property name="url" value="$&#123;url&#125;"/&gt; &lt;property name="username" value="$&#123;username&#125;"/&gt; &lt;property name="password" value="$&#123;password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;environment id="bbb"&gt; &lt;transactionManager type="JDBC"&gt; &lt;property name="..." value="..."/&gt; &lt;/transactionManager&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;driver&#125;"/&gt; &lt;property name="url" value="$&#123;url&#125;"/&gt; &lt;property name="username" value="$&#123;username&#125;"/&gt; &lt;property name="password" value="$&#123;password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; environments中设置default代表默认选择的环境，如果要默认选择bbb把default改成bbb就好了在MyBatis中一个SqlSessionFactory只能与一个环境所绑定如果不希望MyBatis绑定默认环境可以使用12//传入参数为MyBatis配置和环境id 注：environment为String类型SqlSessionFactoryBuilder().build(reader, environment); transactionManager(事物管理器)MyBatis有两种事物管理器，也就是说transactionManager的type值不能随意写，它只有两个值那就是type=”[JDBC|MANAGED]”官方解释： JDBC – 这个配置就是直接使用了 JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域。 MANAGED – 这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将 closeConnection 属性设置为 false 来阻止它默认的关闭行为。例如:123&lt;transactionManager type="MANAGED"&gt; &lt;property name="closeConnection" value="false"/&gt;&lt;/transactionManager&gt; 一般情况下type值都是JDBC 注： 如果你正在使用 Spring + MyBatis，则没有必要配置事务管理器， 因为 Spring 模块会使用自带的管理器来覆盖前面的配置。 dataSource(数据源)type同样是一个枚举值,它的值可以为UNPOOLED、POOLED、JNDI，默认情况下写POOLED就好了关于三个枚举值的含义大家可以去官网查看，由于太长了在这里就不贴出来了。 mappers(映射器)在MyBatis中配置映射有四种方式：123456&lt;!-- 使用相对于类路径的资源引用 --&gt;&lt;mappers&gt; &lt;mapper resource="org/mybatis/builder/AuthorMapper.xml"/&gt; &lt;mapper resource="org/mybatis/builder/BlogMapper.xml"/&gt; &lt;mapper resource="org/mybatis/builder/PostMapper.xml"/&gt;&lt;/mappers&gt; 123456&lt;!-- 使用完全限定资源定位符（URL） --&gt;&lt;mappers&gt; &lt;mapper url="file:///var/mappers/AuthorMapper.xml"/&gt; &lt;mapper url="file:///var/mappers/BlogMapper.xml"/&gt; &lt;mapper url="file:///var/mappers/PostMapper.xml"/&gt;&lt;/mappers&gt; 123456&lt;!-- 使用映射器接口实现类的完全限定类名 --&gt;&lt;mappers&gt; &lt;mapper class="org.mybatis.builder.AuthorMapper"/&gt; &lt;mapper class="org.mybatis.builder.BlogMapper"/&gt; &lt;mapper class="org.mybatis.builder.PostMapper"/&gt;&lt;/mappers&gt; 1234&lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt;&lt;mappers&gt; &lt;package name="org.mybatis.builder"/&gt;&lt;/mappers&gt;]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis01--初识MyBatis]]></title>
    <url>%2F2018%2F04%2F03%2Fmybatis01%2F</url>
    <content type="text"><![CDATA[近日要开始MyBatis的学习了，首先第一件事当然是看官方文档啦 附上官方文档http://www.mybatis.org/mybatis-3/zh/index.html 创建maven工程名称任意，创一个最简单的maven工程就好了 引入MyBatis在pom.xml中加入MyBatis依赖和数据库驱动，我这里用的是mysql1234567891011&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;x.x.x&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.46&lt;/version&gt;&lt;/dependency&gt; x.x.x填的是MyBatis的版本号，目前最新稳定版是3.4.6 编写配置文件由xml构建SqlSessionFactory,首先编写XML配置，以下所有中文均改成自己的配置1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="数据库驱动"/&gt; &lt;property name="url" value="url地址"/&gt; &lt;property name="username" value="用户名"/&gt; &lt;property name="password" value="密码"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource="mapper路径"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 编写mapper配置文件：123456789&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="org.mybatis.example.BlogMapper"&gt; &lt;select id="selectUser" resultType="com.yhzl.bean.User"&gt; select * from User where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 编写实体类及测试类实体类：1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.yhzl.bean;/** * @author chsm * @date 2018年4月4日上午8:30:32 * @version 1.0 */public class User &#123; private Integer id; private String username; private String password; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString() &#123; return "User [id=" + id + ", username=" + username + ", password=" + password + "]"; &#125;&#125; 测试类:12345678910111213141516171819202122232425262728package com.yhzl.test;import java.io.IOException;import java.io.InputStream;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import com.yhzl.bean.User;/** * @author chsm * @date 2018年4月4日上午8:33:13 * @version 1.0 */public class Test &#123; public static void main(String[] args) throws IOException &#123; InputStream inputStream = Resources.getResourceAsStream("mybatis-config.xml"); SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession session = sessionFactory.openSession(); User user = session.selectOne("org.mybatis.example.BlogMapper.selectUser", 1); System.out.println(user); &#125; &#125; 对代码的编写已经完成了此时可以运行了，如果出现报错等情况，请检查下代码看看有没有写错]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[team]]></title>
    <url>%2F2018%2F04%2F03%2Fteam%2F</url>
    <content type="text"><![CDATA[团队协作要求统一开发环境版本： eclipse4.7.3tomcat8.5java8(细节版本待定) 开发所需条件 1.下载并安装git2.注册github账号3.掌握git基本命令，能独立完成远程仓库的提交及clone4.掌握makedown基本语法，编写文档 开发注意事项 不得强制提交带有冲突的项目不得使用与团队不一致的开发环境每次提交需注明新增功能，，并更新md文件在md文件夹下新建人名.md,编写详细的更新文档 团队协作流程 1.组长分配任务并初始化项目提交至远程仓库2.组员从远程仓库clone项目导入eclipse进行开发3.每天21点前将代码提交至远程仓库4.每天24点前组长对项目进行整合纠错并提交至远程仓库 附录git官网github官网MarkDown文档git教程注: git教程无需完整看完掌握基本使用方法即可]]></content>
      <categories>
        <category>团队</category>
      </categories>
      <tags>
        <tag>team</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot(2)--spring boot集成swagger2]]></title>
    <url>%2F2018%2F04%2F03%2Fspring-boot2%2F</url>
    <content type="text"><![CDATA[swagger2是什么？简单来说swagger2是一个可以帮你更好的测试REST风格的API插件 什么是REST风格？传统的请求URL是http://www.test.com/getUser?userId=1REST风格的URL是http://www.test.com/getUser/1百度百科解释 环境Windows10 家庭版Spring Boot 2.0eclipse4.7.3jdk1.8 spring boot集成swagger2初始化项目此次初始化用到了Spring插件，没有插件的直接创建maven工程就好了首先右键新建项目选择other，然后找到Spring Boot下的Spring Starter Project,选中然后点击next点击next后请确保电脑网络异常，因为要通过网络加载配置name处可更改项目名称，在这里我就不改了，继续点击next然后选中以下几项，如果不需要数据库，可不勾选sql下的组件然后点击finish 添加swagger2依赖此时一个Spring Boot项目就算初始化成功了，这时候我们来配置pom.xml加入swagger2和swagger ui依赖123456789101112&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt;&lt;/dependency&gt; 编写实体类及配置信息现在我们来编写一个实体类User:12345678910111213141516171819202122232425package com.example.demo.bean;public class User &#123; private Integer id; private String username; private String password; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; 编写mapper:1234567891011121314package com.example.demo.mapper;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Select;import com.example.demo.bean.User;@Mapperpublic interface UserMapper &#123; @Select("SELECT * FROM User WHERE id=#&#123;id&#125;") User getUser(Integer id);&#125; 编写controller:123456789101112131415161718192021222324package com.example.demo.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import com.example.demo.bean.User;import com.example.demo.mapper.UserMapper;@Controllerpublic class UserController &#123; @Autowired private UserMapper userMapper; @ResponseBody @RequestMapping("/user/&#123;id&#125;") public User getUser(@PathVariable("id") Integer id) &#123; return userMapper.getUser(id); &#125;&#125; 在resource的application.properties中加入数据库配置信息:123spring.datasource.url=数据库地址spring.datasource.username=数据库用户名spring.datasource.password=数据库密码 在测试类中添加一个@EnableSwagger2注解123456789101112131415package com.example.demo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import springfox.documentation.swagger2.annotations.EnableSwagger2;@EnableSwagger2@SpringBootApplicationpublic class Demo1Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Demo1Application.class, args); &#125;&#125; 启动Spring Boot验证是否成功启动Spring Boot然后访问localhost:8080/swagger-ui.html此时若出现以下画面即代表启动成功这时候我们可以测试下，点击user-controller然后再点击GET测试成功结果：]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot(1)--初识spring boot]]></title>
    <url>%2F2018%2F04%2F02%2Fspring-boot1%2F</url>
    <content type="text"><![CDATA[今天对着视频尝试着写了一下Spring Boot，下面说一下感受与问题 感受 不得不说Spring Boot真的是十分好用啊，总的来说就是配置简单， 启动快速， 极易上手 环境Windows10 家庭版Spring Boot 2.0eclipse4.7.3jdk1.8 配置首先新建一个maven工程，然后将以下几行代码复制到pom.xml中1234567891011&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.0.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 这时候maven基本就配置好了，接下来我们来写java代码，首先新建一个类名称任意，然后写一个main方法，如果安装了Spring插件的话，eclipse会有两个main方法提示这时候选第二个就好了对于没有安装插件的朋友只需要这样写main方法就好了,注意当中的SampleController.class,要改成类名.class123public static void main(String[] args) throws Exception &#123; SpringApplication.run(SampleController.class, args); &#125; 然后在类上加上@SpringBootApplication注解就好了，这个时候Spring Boot就可以跑起来了完整代码：123456@SpringBootApplicationpublic class SampleController &#123; public static void main(String[] args) throws Exception &#123; SpringApplication.run(SampleController.class, args); &#125;&#125; 然后我们就可以在浏览器输入localhost:8080访问了访问成功的页面是这样的：这时候我们就可以开始编写Controller，让Spring Boot显示出Hello Spring Boot了Controller的编写也很简单这里就直接附上代码了：12345678@Controllerpublic class HelloController &#123; @ResponseBody @RequestMapping("/hello") public String hello() &#123; return "Hello Spring Boot"; &#125;&#125; 这时候再重启服务器访问localhost:8080/hello浏览器就会显示Hello Spring Boot啦成功界面：当然大家也可以直接按照官方的例子，编写Spring Boot程序：123456789101112131415161718192021package hello;import org.springframework.boot.*;import org.springframework.boot.autoconfigure.*;import org.springframework.stereotype.*;import org.springframework.web.bind.annotation.*;@Controller@EnableAutoConfigurationpublic class SampleController &#123; @RequestMapping("/") @ResponseBody String home() &#123; return "Hello World!"; &#125; public static void main(String[] args) throws Exception &#123; SpringApplication.run(SampleController.class, args); &#125;&#125; 最后附上Spring Boot的官网和文档 Spring Boot官网：https://projects.spring.io/spring-boot/官方文档：https://docs.spring.io/spring-boot/docs/2.0.0.RELEASE/reference/htmlsingle/]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello, Hexo]]></title>
    <url>%2F2018%2F03%2F30%2Fhello-Hexo%2F</url>
    <content type="text"><![CDATA[刚搭建好博客，第一篇博客就说一下如何配置Hexo到GitHub吧！ 我的环境是Windows10 家庭版 64位 安装node.js和gitnode的安装说实话具体的安装步骤我已经忘了，因为很久前我就安装了，估计也就一直下一步就好了，在这里给出下载链接，如果安装过程中出现问题的话，请各位自行百度解决下 以下是安装成功的样子 git的安装git下载地址,我安装的时候是一直下一步就好了 安装成功后在空白处单击右键会出现以下两个图标 注册GitHub并新建项目注册没什么好说的直接到GitHub官网注册就好新建项目时注意项目名必须是用户名.github.io，否则可能会无法访问 安装Hexo在自己喜欢的地方创建文件夹，名称任意，用于存放Hexo，然后按住Shift + 鼠标右键会发现有个 单击它打开命令行窗口，输入 npm install hexo -g 开始安装Hexo 经过一段时间的等待，hexo就安装好了，此时可以输入 hexo -v 验证是否安装成功成功效果图： 然后输入 hexo init 开始初始化hexo，经过一段时间的等待，当看到Start blogging with Hexo！时，就代表初始化已经完成了，此时再输入 npm install 安装所需组件,安装完成后再输入 hexo g 然后输入 hexo s 开启服务，此时如果不出意外在浏览器输入localhost:4000就可以访问到首页了，然后hexo基本已经安装完毕了，下一步要开始上传到git了 配置git首先打开 Git Bash，设置用户名和邮箱 git config –global user.name “用户名”git config –global user.email “邮箱地址” 输入以下代码可查看配置信息 git config -l 完成后输入以下代码生成秘钥(输入后按下三次回车) ssh-keygen -t rsa -b 4096 -C “邮箱地址” 启动ssh-agent eval $(ssh-agent -s) 生成ssh key到ssh-agent ssh-add ~/.ssh/id_rsa 使用命令复制秘钥 clip &lt; ~/.ssh/id_rsa.pub 登录GitHub点击头像下的setting然后点击再点击将复制好的秘钥粘贴进去即可进去即可输入以下代码验证是否成功，若Hi后出现你的github名称，就代表秘钥添加成功 ssh -T git@github.com 配置hexo目录下的_config.yml ,deploy在文件的最下面1234deploy: type: git repository: 新建项目中的SSH branch: master 在此复制SSH地址，粘贴到repository中在命令行输入安装扩展 npm install hexo-deployer-git –save 完成后输入 hexo d -g 即可完成整个hexo的部署输入用户名.github.io即可访问]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
