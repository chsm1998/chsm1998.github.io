<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[mysql-02-日志系统]]></title>
    <url>%2F2020%2F03%2F10%2Fmysql-02%2F</url>
    <content type="text"><![CDATA[序言MySQL中的日志主要分为两种，1.redo log（重做日志）InnoDB独有；2.binlog（归档日志）MySQL Server层日志，跨引擎。 日志模块：redo log（重做日志）redo log是存储引擎层面的日志，为InnoDB独有。在执行更新数据库操作时都会向redo log中写入一条日志。 如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高。为了解决这个问题，MySQL采用了 WAL 技术，WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘。 具体来说，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做 InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写 如图： write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。 write pos 和 checkpoint 之间的是redo log还空着的部分，可以用来记录新的操作。如果 write pos 追上 checkpoint，表示日志满了，这时候不能再执行新的更新，得停下来先把部分数据存入磁盘，把 checkpoint 推进一下。 有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 crash-safe。 日志模块之binlog（归档日志）binlog是MySQL Server层的日志，与具体存储引擎实现无关。 为什么MySQL会存在两份日志？ 因为最开始 MySQL 里并没有 InnoDB 引擎。MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统——也就是 redo log 来实现 crash-safe 能力。 这两种日志有以下三点不同。 redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。 redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。 redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。 更新 SQL 执行流程： 找到需要更新的数据，若在内存中则直接返回；否则先从磁盘中读入内存在返回。 执行器拿到引擎给的数据，将数据更新得到新的一行数据，再调用引擎接口写入这行新数据。 引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。 执行器生成这个操作的 binlog，并把 binlog 写入磁盘。 执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。 InnoDB将redo log的写入拆成了两个步骤：prepare 和 commit，这就是”两阶段提交”。 两阶段提交为什么必须有“两阶段提交”呢？这是为了让两份日志之间的逻辑一致。 误删表数据恢复前面我们说过了，binlog 会记录所有的逻辑操作，并且是采用“追加写”的形式。如果你的 DBA 承诺说半个月内可以恢复，那么备份系统中一定会保存最近半个月的所有 binlog，同时系统会定期做整库备份。这里的“定期”取决于系统的重要性，可以是一天一备，也可以是一周一备。 如果发生误删表补救流程： 首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库； 然后，从备份的时间点开始，将备份的 binlog 依次取出来，重放到误删表之前的那个时刻。 这样你的临时库就跟误删之前的线上库一样了，然后你可以把表数据从临时库取出来，按需要恢复到线上库去。 两阶段提交存在的意义说完数据恢复，我们再来说说为什么需要两阶段提交 由于 redo log 和 binlog 是两个独立的逻辑，如果不用两阶段提交，要么就是先写完 redo log 再写 binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。 先写 redo log 后写 binlog。假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。由于我们前面说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来。但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。导致数据丢失。 先写 binlog 后写 redo log。如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效。但是 binlog 里面已经记录了这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的值与原库的值不同。 线上库推荐参数设置redo log 用于保证 crash-safe 能力。innodb_flush_log_at_trx_commit 这个参数设置成 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘。这个参数我建议你设置成 1，这样可以保证 MySQL 异常重启之后数据不丢失。 sync_binlog 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。这个参数我也建议你设置成 1，这样可以保证 MySQL 异常重启之后 binlog 不丢失。 疑问 两阶段提交如何保证commit的时候，redo log和binlog，都成功写入磁盘？假设redo log写完后系统出现异常，数据如何回滚？该操作的原子性是由操作系统保证的还是由MySQL来保证的？]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql-01-基础架构]]></title>
    <url>%2F2020%2F03%2F09%2Fmysql-01%2F</url>
    <content type="text"><![CDATA[序言本篇及后续mysql文章集合中的知识均来自于极客时间的《MySQL实战45讲》专栏，文章的目的只是为了对专栏学习的一个知识汇总。由于是对专栏知识的一个总体概括，可能每篇文章与专栏的顺序不是一一对应的。 主要内容MySQL主体架构MySQL的基本架构大体上可以分为Server层和存储引擎两个部分 Server层Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等 存储引擎而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。 连接器连接器负责跟客户端建立连接、获取权限、维持和管理连接 如果用户名或密码不对，你就会收到一个”Access denied for user”的错误，然后客户端程序结束执行。 如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。 这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。 建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。 MySQL长连接注意事项但是全部使用长连接后，你可能会发现，有些时候 MySQL 占用内存涨得特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。 解决方案 定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。 如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。 查询缓存MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。key 是查询的语句，value 是查询的结果。如果你的查询能够直接在这个缓存中找到 key，那么这个 value 就会被直接返回给客户端。 如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。你可以看到，如果查询命中缓存，MySQL 不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。 但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。 查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。 需要注意的是，MySQL 8.0 版本直接将查询缓存的整块功能删掉了，也就是说 8.0 开始彻底没有这个功能了。 分析器分析器先会做“词法分析”。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。 MySQL 从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。 做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。 优化器优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。 比如你执行下面这样的语句，这个语句是执行两个表的 join： 1mysql&gt; select * from t1 join t2 using(ID) where t1.c=10 and t2.d=20; 既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。 也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。 执行器SQL开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误，如下所示 (在工程实现上，如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证。查询也会在优化器之前调用 precheck 验证权限)。 如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。比如我们这个例子中的表 T 中，ID 字段没有索引，那么执行器的执行流程是这样的： 调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中； 调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。 对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建多线程方式之Callable]]></title>
    <url>%2F2019%2F06%2F07%2Fmultithreading-05%2F</url>
    <content type="text"><![CDATA[前言前面我们说到了实现多线程的两种方式，分别是实现Runnable接口和继承Thread类。那么实现Callable接口和他们有什么区别呢？ 通过Callable接口实现多线程1234567891011121314151617181920212223242526272829303132package com.example.socket.multithreading;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;public class CallableTest implements Callable &#123; @Override public Object call() &#123; int sum = 0; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(i); sum += i; &#125; return sum; &#125; public static void main(String[] args) &#123; CallableTest callableTest = new CallableTest(); FutureTask futureTask = new FutureTask(callableTest); Thread thread = new Thread(futureTask); thread.start(); try &#123; Object o = futureTask.get(); System.out.println("总和为：" + o); &#125; catch (InterruptedException | ExecutionException e) &#123; e.printStackTrace(); &#125; &#125;&#125; Callable与Runnable的异同 通过实现Callable接口我们可以获取方法的返回值 通过实现Callable接口我们可以抛出异常 通过实现Callable接口我们可以使用泛型定义方法的返回值]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Java多线程之线程间的通信]]></title>
    <url>%2F2019%2F06%2F06%2Fmultithreading-04%2F</url>
    <content type="text"><![CDATA[使用线程通信完成交替打印1-100实现原理实现线程间的交替打印主要是通过wait()和notify()两个方法。下面我们来讲一下几个相关方法的作用 注：以下3个方法都必须在同步代码块或同步方法中调用，否则会抛出java.lang.IllegalMonitorStateException异常 wait()：一旦执行该方法，当前线程就会进入阻塞状态，并释放同步监视器(意味着其他线程可以进入)。 notify()：一旦执行该方法，就会唤醒一个wait的线程，如果有多个线程wait，则唤醒优先级最高的那个。 notifyAll()：一旦执行该方法，会唤醒所有被wait的线程。 实现代码1234567891011121314151617181920212223242526272829303132333435363738package com.example.socket.multithreading;class RunnableImpl2 implements Runnable &#123; private int num = 1; @Override public void run() &#123; while (true) &#123; synchronized (this) &#123; notify(); if (num &lt;= 100) &#123; System.out.println(Thread.currentThread().getName() + ":" + num); num++; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; else &#123; break; &#125; &#125; &#125; &#125;&#125;public class CommunicationThread &#123; public static void main(String[] args) &#123; Runnable runnable = new RunnableImpl2(); Thread thread1 = new Thread(runnable); Thread thread2 = new Thread(runnable); thread1.setName("线程1"); thread2.setName("线程2"); thread1.start(); thread2.start(); &#125;&#125; 分析代码执行过程 注：以下描述的同步监视器等同于锁 我们以A、B来代替代码中的两个线程，首先两个线程其他，假设A抢到了CPU执行权，则执行run方法，首先线程A调用notify()方法，此时没有线程wait，所以不会唤醒任何线程，然后A打印出1，并执行num++，最后线程A调用wait()方法。此时线程A进入阻塞状态，释放同步监视器，线程B可以拿到锁。然后线程B调用notify()方法唤醒线程A，由于锁没释放，所以线程A暂时不能执行。最后线程B调用wait()方法，进入阻塞状态，释放同步监视器。然后线程A可以拿到锁，执行相应代码，如此循环往复就会出现交替打印的效果。 sleep与wait方法有什么区别？相同点执行这两个方法后都会使线程进入阻塞状态 不同点 sleep方法声明在Thread类中，而wait方法声明咋Object类当中。 sleep方法可以在任意场景当中调用，而wait方法只能在同步代码块或同步方法中调用。 sleep方法调用后不会释放同步监视器，而wait方法调用后会释放同步监视器。 生产者消费者问题问题描述生产者和消费者问题是线程模型中的经典问题：生产者和消费者在同一时间段内共用同一个存储空间，生产者往存储空间中添加产品，消费者从存储空间中取走产品，当存储空间为空时，消费者阻塞，当存储空间满时，生产者阻塞。 实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package com.example.socket.multithreading;/** * 负责通知生产和消费的店员 */class Clerk &#123; private static Integer num = 0; public synchronized void product() &#123; if (num &lt; 20) &#123; num++; System.out.println(Thread.currentThread().getName() + "开始生产第" + num + "件商品"); notify(); &#125; else &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public synchronized void customer() &#123; if (num &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + "开始消费第" + num + "件商品"); num--; notify(); &#125; else &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;/** * 生产者 */class Product implements Runnable &#123; private Clerk clerk; public Product(Clerk clerk) &#123; this.clerk = clerk; &#125; @Override public void run() &#123; System.out.println("开始生产："); while (true) &#123; clerk.product(); try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;/** * 消费者 */class Customer implements Runnable &#123; private Clerk clerk; public Customer(Clerk clerk) &#123; this.clerk = clerk; &#125; @Override public void run() &#123; System.out.println("开始消费："); while (true) &#123; clerk.customer(); try &#123; Thread.sleep(20); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;public class ProductAndCustomer &#123; public static void main(String[] args) &#123; Clerk clerk = new Clerk(); Thread thread = new Thread(new Customer(clerk)); Thread thread1 = new Thread(new Product(clerk)); thread.setName("消费者"); thread1.setName("生产者"); thread.start(); thread1.start(); &#125;&#125; 该段代码实现原理基本与交替打印类似，不再详述。]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Java多线程之synchronized]]></title>
    <url>%2F2019%2F06%2F02%2Fmultithreading-03%2F</url>
    <content type="text"><![CDATA[线程安全问题提到多线程，就不得不提线程安全问题。线程安全问题发生的首要因素就是，多个线程操作共享变量。只有在操作共享变量时才可能出现线程安全问题，对于局部变量的操作，是不会导致线程安全问题的。 注：本篇文章只讨论线程争抢导致数据不一致问题，不讨论原子性、可见性等问题。示例代码：123456789101112131415161718192021222324252627282930313233343536373839package com.example.socket.multithreading;public class SafetyThread &#123; private static int num = 0; public static void main(String[] args) &#123; Thread thread1 = new Thread(() -&gt; &#123; while (num &lt; 100) &#123; System.out.println(Thread.currentThread().getName() + ":" + num); num++; &#125; &#125;);Thread thread2 = new Thread(() -&gt; &#123; while (num &lt; 100) &#123; System.out.println(Thread.currentThread().getName() + ":" + num); num++; &#125; &#125;); // 存在线程安全问题 thread1.start(); thread2.start(); Thread thread3 = new Thread(() -&gt; &#123; int num = 0; while (num &lt; 100) &#123; System.out.println(Thread.currentThread().getName() + ":" + num); num++; &#125; &#125;);Thread thread4 = new Thread(() -&gt; &#123; int num = 10; while (num &lt; 100) &#123; System.out.println(Thread.currentThread().getName() + ":" + num); num++; &#125; &#125;); // 不存在线程安全问题 thread3.start(); thread4.start(); &#125;&#125; synchronized是什么？synchronized是Java当中的一种同步锁，使用synchronized锁住的代码块都是同步方法 如何使用synchronized解决线程安全问题一下代码均取自初识Java多线程之创建多线程的几种方式(一)中的代码只修改了其中的run方法。 用synchronized解决实现Runnable接口的线程安全问题 锁住整个run方法 123456789101112@Overridepublic synchronized void run() &#123; while (num &gt; 0) &#123; try &#123; Thread.sleep(50); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "当前票号：" + num); num--; &#125;&#125; 锁住this 123456789@Overridepublic void run() &#123; synchronized (this) &#123; while (num &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + "当前票号：" + num); num--; &#125; &#125;&#125; 锁住一个对象 1234567891011private Object obj = new Object();@Overridepublic void run() &#123; synchronized (obj) &#123; while (num &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + "当前票号：" + num); num--; &#125; &#125;&#125; 锁住当前类 123456789@Overridepublic void run() &#123; synchronized (RunnableImpl.class) &#123; while (num &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + "当前票号：" + num); num--; &#125; &#125;&#125; 用synchronized解决继承Thread类的线程安全问题 锁住一个静态方法注：必须将synchronized加在静态方法上，防止run或者非静态方法上都是无效的，因为此时的锁不是同一个对象 1234567891011@Overridepublic void run() &#123; show();&#125;public synchronized static void show() &#123; while (num &gt; 0) &#123; System.out.println(currentThread().getName() + "当前票号：" + num); num--; &#125;&#125; 锁静态对象注：该对象必须是静态的，原因同1 1234567891011private static Object object = new Object();@Overridepublic void run() &#123; synchronized (object) &#123; while (num &gt; 0) &#123; System.out.println(currentThread().getName() + "当前票号：" + num); num--; &#125; &#125;&#125; 锁住当前类 123456789@Overridepublic void run() &#123; synchronized (ExtendThread.class) &#123; while (num &gt; 0) &#123; System.out.println(currentThread().getName() + "当前票号：" + num); num--; &#125; &#125;&#125; 对于继承Thread的线程不能通过锁this来保证线程安全，因为此时的this不是同一对象。 synchronized解惑synchronized锁对象的要求是什么？synchronized锁住的对象，对于多个线程来说必须是同一对象，换言之，多个线程必须使用同一把锁。若多个线程使用不同的锁，将不能保证线程安全问题 将synchronized加在方法上时锁住的到底是什么？synchronized加在普通方法上时，锁住的是当前的this。加在静态方法上时锁住的是当前类 synchronized缺陷synchronized会导致所有方法都是同步执行的对效率有一定影响，所以要控制好锁力度，能锁部分方法体就锁部分方法体，不要锁住整个方法。对于不会发生线程安全的代码块不要随意加锁。]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Java多线程之多线程中的常用方法]]></title>
    <url>%2F2019%2F06%2F02%2Fmultithreading-02%2F</url>
    <content type="text"><![CDATA[多线程中的常用方法 start() 启动当前线程，并调用当前线程的run方法 run() 重写Thread或Runnable的run，供系统调用，不得手动调用 currentThread() Thread中的静态方法，获取当前线程 getName() 获取当前线程的名称 setName() 设置当前线程的名称 yield() 释放当前CPU的执行权 join() 当线程a调用线程b的join方法，线程a就进入阻塞状态，直至线程b执行结束。 stop() 已过时，强制结束当前线程 sleep(long time) 使当前线程进入睡眠状态，time为睡眠的毫秒数。睡眠时线程处于阻塞状态 isAlive() 判断当前线程是否存活 下面我们来着重说明一下 yield(), join() 两个方法，其他方法都是字面意思不再另外说明 yield当线程a调用yield方法是会让出CPU执行权，此时线程a和线程b重新开始CPU执行权争抢，谁抢到谁执行。yield不保证线程b一定能够抢到CPU执行权，可能还是线程a在执行示例代码：1234567891011121314151617181920212223242526272829package com.example.socket.multithreading;/** * 当线程a调用yield方法是会让出CPU执行权，此时线程a和线程b重新开始CPU执行权争抢，谁抢到谁执行。 * yield不保证线程b一定能够抢到CPU执行权，可能还是线程a在执行 * 注：该段代码必须在jdk1.8及以上版本才能运行 */public class YieldThread &#123; public static void main(String[] args) &#123; // lambda表达式 Thread thread = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName() + ":" + i); if (i == 20) &#123; Thread.yield(); &#125; &#125; &#125;); Thread thread1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName() + ":" + i); &#125; &#125;); thread.start(); thread1.start(); &#125;&#125; join当线程a调用线程b的join方法，线程a就进入阻塞状态，直至线程b执行结束，线程a再执行。123456789101112131415161718192021222324252627282930package com.example.socket.multithreading;/** * 当线程a调用线程b的join方法，线程a就进入阻塞状态，直至线程b执行结束，线程a再执行。 */public class JoinThread &#123; public static void main(String[] args) &#123; Thread thread = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName() + ":" + i); &#125; &#125;); Thread thread1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName() + ":" + i); if (i == 20) &#123; try &#123; thread.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;); thread.start(); thread1.start(); &#125;&#125;]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Java多线程之创建多线程的几种方式(一)]]></title>
    <url>%2F2019%2F06%2F02%2Fmultithreading-01%2F</url>
    <content type="text"><![CDATA[前言个人认为多线程属于java的中高级知识，是java当中的重点。也是面试中的几大难点之一。作为初学者往往搞不明白多线程。我个人对多线程也没有太深入的认识，所以这几天也在看多线程相关的知识。在此记录下来以供学习参考。 创建多线程的两种方式虽然标题是创建多线程的两种方式，但实际上创建多线程的方式不止两种。本篇文章暂时说两种简单常见的。其他创建方式将在后续文章补充。 本篇文章中的代码都不是线程安全的，仅供参考。 继承Thread类我们只需要继承Thread类，然后实现其中的run方法即可。使用时只需new出Thread实现对象，然后调用start方法即可示例代码：123456789101112131415161718192021222324252627282930package com.example.socket.multithreading;/** * 创建多线程方式一：继承Thread类 */public class ExtendThread extends Thread &#123; private static int num = 100; @Override public void run() &#123; while (num &gt; 0) &#123; System.out.println(currentThread().getName() + "当前票号：" + num); num--; &#125; &#125; public static void main(String[] args) &#123; Thread extendThread1 = new ExtendThread(); Thread extendThread2 = new ExtendThread(); Thread extendThread3 = new ExtendThread(); // 注意要调用start方法而不是run方法 // 错误 // extendThread1.run(); // 正确 extendThread1.start(); extendThread2.start(); extendThread3.start(); &#125;&#125; 实现Runnable接口与继承Thread类基本一致，都是实现run方法，然后调用start方法启动线程。示例代码：1234567891011121314151617181920212223242526272829package com.example.socket.multithreading;/** * 创建多线程方式二：实现Runnable接口方式 */public class RunnableImpl implements Runnable &#123; private int num = 100; @Override public void run() &#123; while (num &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + "当前票号：" + num); num--; &#125; &#125; public static void main(String[] args) &#123; // 创建Runnable实现类 Runnable runnable = new RunnableImpl(); // 放入Thread的构造器中 Thread thread1 = new Thread(runnable); Thread thread2 = new Thread(runnable); Thread thread3 = new Thread(runnable); thread1.start(); thread2.start(); thread3.start(); &#125;&#125; 两种创建多线程方式应该选用哪种？个人倾向于选择实现Runnable的方式。因为Java只能单继承，一旦继承了Thread类就不能继承其他父类了。但是Java可以实现多个接口，所以实现Runnable接口不影响程序可扩展性。 透过现象看本质我们都知道调用start启动一个线程之后，最终会执行该线程的run方法。在继承Thread类的时候，由于我们实现了run方法，所以启动线程，最终会调用子类当中的run方法。但是我们实现Runnable接口并没有显式或隐式的继承Thread，那么我们的run方法是怎么被调用的呢？通过看Thread的源码可以发现，Thread也实现了Runnable接口，当中也有一个run方法。在我们start的时候调用的其实是Thread中的run方法。以下是该方法的实现。123456@Overridepublic void run() &#123; if (target != null) &#123; target.run(); &#125;&#125; 我们发现在target不为null的情况下会调用target的run方法，那么这个target是谁呢？这个target就是我们传入Thread构造器的Runnable的实现类123public Thread(Runnable target) &#123; init(null, target, "Thread-" + nextThreadNum(), 0);&#125; 所以虽然我们并没有显式或隐式的继承Thread但是最终调用的还是我们自己实现的run方法。 线程的生命周期]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中的socket(01)]]></title>
    <url>%2F2019%2F06%2F01%2Fjava-socket-01%2F</url>
    <content type="text"><![CDATA[学习socket的起因原因就是工作中有个项目要用到socket，第一次听到socket这个词的时候一脸懵逼，java中还有这玩意？不都是SSM一套用HTTP请求吗？怎么还有socket这个玩意？ socket是什么？摘自百度百科: 网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。 才疏学浅，个人没办法明确描述socket是什么。不过定义不重要，重要的是如何使用它。 如何使用socket？创建socket服务端服务端多线程处理客户端请求123456789101112131415161718192021222324252627282930313233343536373839/** * 该类为多线程类，用于服务端 */ public class ServerThread implements Runnable &#123; private Socket client = null; public ServerThread(Socket client)&#123; this.client = client; &#125; @Override public void run() &#123; try&#123; //获取Socket的输出流，用来向客户端发送数据 PrintStream out = new PrintStream(client.getOutputStream()); //获取Socket的输入流，用来接收从客户端发送过来的数据 BufferedReader buf = new BufferedReader(new InputStreamReader(client.getInputStream())); boolean flag =true; while(flag)&#123; //接收从客户端发送过来的数据 String str = buf.readLine(); if(str == null || "".equals(str))&#123; flag = false; &#125;else&#123; if("bye".equals(str))&#123; flag = false; &#125;else&#123; //将接收到的字符串前面加上echo，发送到对应的客户端 out.println("echo:" + str); &#125; &#125; &#125; out.close(); client.close(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125; 开启服务端12345678910111213141516public class Server1 &#123; public static void main(String[] args) throws Exception&#123; //服务端在20006端口监听客户端请求的TCP连接 ServerSocket server = new ServerSocket(20006); Socket client = null; boolean f = true; while(f)&#123; //等待客户端的连接，如果没有获取连接 client = server.accept(); System.out.println("与客户端连接成功！"); //为每个客户端连接开启一个线程 new Thread(new ServerThread(client)).start(); &#125; server.close(); &#125; &#125; 编写socket客户端123456789101112131415161718192021222324252627282930313233343536public class Client1 &#123; public static void main(String[] args) throws IOException &#123; //客户端请求与本机在20006端口建立TCP连接 Socket client = new Socket("127.0.0.1", 20006); client.setSoTimeout(10000); //获取键盘输入 BufferedReader input = new BufferedReader(new InputStreamReader(System.in)); //获取Socket的输出流，用来发送数据到服务端 PrintStream out = new PrintStream(client.getOutputStream()); //获取Socket的输入流，用来接收从服务端发送过来的数据 BufferedReader buf = new BufferedReader(new InputStreamReader(client.getInputStream())); boolean flag = true; while(flag)&#123; System.out.print("输入信息："); String str = input.readLine(); //发送数据到服务端 out.println(str); if("bye".equals(str))&#123; flag = false; &#125;else&#123; try&#123; //从服务器端接收数据有个时间限制（系统自设，也可以自己设置），超过了这个时间，便会抛出该异常 String echo = buf.readLine(); System.out.println(echo); &#125;catch(SocketTimeoutException e)&#123; System.out.println("Time out, No response"); &#125; &#125; &#125; input.close(); if(client != null)&#123; //如果构造函数建立起了连接，则关闭套接字，如果没有建立起连接，自然不用关闭 client.close(); //只关闭socket，其关联的输入输出流也会被关闭 &#125; &#125; &#125; 使用socket的个人体会 写出一个简单的服务端/客户端Demo很容易，实际使用并不简单 socket和HTTP不同，HTTP有请求就有响应，而socket可以没有响应。又或者说socket根本就没有响应这个概念。因为socket是全双工的，所以它的请求和响应都一样。这就需要在使用过程中分辨请求和响应。 socket必须要鉴权，在第一次使用socket的时候我就在想，这不是只要我开放了端口谁都可以连接上我的socket服务端吗？所以用socket一定要鉴权，对非法连接拒之门外（虽然我不知道的怎么做，但是一定要做）。 socket读取数据十分麻烦，TCP/IP是传输层协议，而HTTP是应用层协议，两者分工不同。自然造就就读取数据的差异。使用socket必须事事亲力亲为，否则什么都办不成。 参考链接java tcp socket编程TCP/IP和socket的关系TCP/IP和HTTP协议的区别]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>socket</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[electron与vue配合生成客户端]]></title>
    <url>%2F2019%2F05%2F26%2Felectron-vue-01%2F</url>
    <content type="text"><![CDATA[electron是什么？官网描述：如果你可以建一个网站，你就可以建一个桌面应用程序。 Electron 是一个使用 JavaScript, HTML 和 CSS 等 Web 技术创建原生程序的框架，它负责比较难搞的部分，你只需把精力放在你的应用的核心上即可。 如何与vue搭配使用？ 首先我们需要创建一个vue项目 安装electron，推荐使用全局安装，不然编译的时候比较麻烦。 npm install -g electron 安装electron-builder，和electron采用全局安装方式 npm install -g electron-builder 对vue项目进行打包，我使用的是yarn，用npm同理 yarn build 进入打包好的dist文件夹，新建main.js和package.json两个文件 main.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// Modules to control application life and create native browser windowconst &#123; app, BrowserWindow &#125; = require('electron')// const isDev = require('electron-is-dev');// const path = require('path');// Keep a global reference of the window object, if you don't, the window will// be closed automatically when the JavaScript object is garbage collected.let mainWindowfunction createWindow() &#123; // Create the browser window. mainWindow = new BrowserWindow(&#123; width: 800, height: 600, webPreferences: &#123; nodeIntegration: true &#125; &#125;) // and load the index.html of the app. // mainWindow.loadURL(url.format(&#123; // pathname: path.join(__dirname, './build/index.html'), // protocol: 'file:', // slashes: true // &#125;)) // const devUrl = 'http://localhost:3000'; // 本地文件路径定位到打包的react文件 const localUrl = `file://$&#123;__dirname&#125;/index.html`; // const appUrl = isDev ? devUrl : localUrl; mainWindow.loadURL(localUrl) // Open the DevTools. // mainWindow.webContents.openDevTools() // Emitted when the window is closed. mainWindow.on('closed', function () &#123; // Dereference the window object, usually you would store windows // in an array if your app supports multi windows, this is the time // when you should delete the corresponding element. mainWindow = null &#125;)&#125;// This method will be called when Electron has finished// initialization and is ready to create browser windows.// Some APIs can only be used after this event occurs.app.on('ready', createWindow)// Quit when all windows are closed.app.on('window-all-closed', function () &#123; // On macOS it is common for applications and their menu bar // to stay active until the user quits explicitly with Cmd + Q if (process.platform !== 'darwin') app.quit()&#125;)app.on('activate', function () &#123; // On macOS it's common to re-create a window in the app when the // dock icon is clicked and there are no other windows open. if (mainWindow === null) createWindow()&#125;)// In this file you can include the rest of your app's specific main process// code. You can also put them in separate files and require them here. package.json1234567891011121314151617&#123; "name": "hello", "productName": "test-electron", "version": "0.1.0", "main": "main.js", "scripts": &#123; "dist": "electron-builder" &#125;, "build": &#123; "directories": &#123; "output": "../test" &#125; &#125;, "nsis": &#123; "oneClick": false &#125;&#125; 最后一步，对electron进行打包，第一次打包时间可能会比较久，因为要下载一下依赖，由于众所周知的原因还可能下载失败，耐心等待一下。 yarn dist 可能出现的问题执行yarn dist下载依赖失败解决办法: 手动下载electron相关依赖，然后放到（不需要解压） C:\Users***\AppData\Local\electron\Cache 手动下载electron-builde相关依赖，然后放到（需要解压） C:\Users***\AppData\Local\electron-builder\Cache 依赖下载成功后打包依然失败将electron-builder中的winCodeSign的所有Plugin复制到nsis当中 参考链接React + Electron 搭建一个桌面应用正确设置 ELECTRON_MIRROR ，加速下载 electron 预编译文件Electron 应用如何利用 create-react-app 从 0 到 1Electron 打包问题：electron-builder 下载各种依赖出错electron 构建打包总结Windows 10 build Error (NSIS)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>electron</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud(2)--服务发现和注册Eureka]]></title>
    <url>%2F2019%2F03%2F04%2Fspring-cloud-eureka%2F</url>
    <content type="text"><![CDATA[概念 服务注册 Eureka Client向Eureka Server注册 服务续约 Eureka Client默认情况下每30秒发送一次心跳来进行服务续约 获取服务注册列表信息 客户端向服务端获取服务注册信息，并将其缓存在本地，每30秒更新一次。如果由于某些原因导致注册信息不能及时匹配，客户端会重新获取整个注册表信息。可使用xml和json通信，默认以json通信。 服务下线 客户端关闭时可向服务端发送下线请求，该请求不会自动完成，需要手动调用如下代码： 注：DiscoveryManager在使用Spring Cloud Greenwich.RELEASE版本时发现为已过时的，具体替代类由于个人实力有限，暂时还不清楚 1DiscoveryManager.getInstance().shutdownComponent(); 服务剔除 在默认情况下，当客户端90秒没有向服务端发送心跳，服务端会将该客户端从注册表中移除 创建Maven主工程由于本案例有多个Spring Boot工程，为了方便管理，采用Maven多Module结构 更改Type首先我们通过idea创建一个Spring Boot工程，将其中的Type由Maven Project更改为Maven POM 修改pom文件创建好spring boot工程后将pom文件做如下修改： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;modules&gt; &lt;module&gt;eureka-server&lt;/module&gt; &lt;module&gt;eureka-client&lt;/module&gt; &lt;/modules&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.3.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.yhzl.cloud&lt;/groupId&gt; &lt;artifactId&gt;test&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;name&gt;test&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Greenwich.RELEASE&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;/project&gt; 创建Eureka Server创建Module在主工程下新增一个Module，名称叫做eureka-server 修改pom文件123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.yhzl.cloud&lt;/groupId&gt; &lt;artifactId&gt;test&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;eureka-server&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;eureka-server&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 修改yml文件1234567891011server: port: 8081eureka: instance: hostname: localhost client: register-with-eureka: false fetch-registry: false service-url: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ 修改EurekaServerApplication文件123456789101112131415package com.yhzl.cloud.eurekaserver;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;@EnableEurekaServer@SpringBootApplicationpublic class EurekaServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaServerApplication.class, args); &#125;&#125; 创建Eureka Client 创建步骤与Eureka Server一致 修改yml文件12345678910eureka: client: service-url: defaultZone: http://localhost:8081/eureka/server: port: 8082spring: application: name: eureka-client 修改EurekaClientApplication文件123456789101112131415package com.yhzl.cloud.eurekaclient;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;@EnableEurekaClient@SpringBootApplicationpublic class EurekaClientApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaClientApplication.class, args); &#125;&#125; 启动项目 构建高可用Eureka Server集群修改Eureka Server的yml文件1234567891011121314151617181920212223242526spring: profiles: peer1 application: name: peer1server: port: 8081eureka: instance: hostname: peer1 client: service-url: defaultZone: http://peer2:8082/eureka/---spring: profiles: peer2 application: name: peer2server: port: 8082eureka: instance: hostname: peer2 client: service-url: defaultZone: http://peer1:8081/eureka/ 配置Windows的hosts 首先以管理员权限打开记事本，然后找到hosts文件，默认是在该路径下 C:\Windows\System32\drivers\etc 然后添加两行代码 127.0.0.1 peer1127.0.0.1 peer2 配置idea参数启动找到Run Dashboard 配置启动项peer1配置参考 peer2配置类似，只需将图中的peer1修改为peer2即可 修改eureka client的yml文件12345678910eureka: client: service-url: defaultZone: http://peer1:8081/eureka/server: port: 8083spring: application: name: eureka-client 该配置文件的意思是，仅向peer1注册服务。 最后运行三个服务，会发现，虽然eureka client仅向peer1注册了服务，但是会自动同步到peer2上 Eureka自我保护机制 默认情况下，如果eureka server在15分钟之内接收到的服务续约率低于85%，那么eureka将会开启自我保护模式，这是为了防止当eureka注册中心自己网络出现故障时，导致了可用的eureka client被意外删除。默认情况下eureka的自我保护机制是开启的，如需关闭，可以在配置文件中添加如下代码 123eureka: server: enable-self-preservation: false 自我保护模式推荐开启，这样可以防止当注册中心网络故障时导致的有效服务不可用。 当然自我保护模式也有坏处，默认情况下服务续约总数=服务总数*2。当服务总数过低时(低于7个)，会导致真正的服务宕机eureka也会开启自我保护模式，因为服务续约率会低于百分之85.]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>spring cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud(1)--初识spring cloud]]></title>
    <url>%2F2019%2F03%2F04%2Fspring-cloud-start%2F</url>
    <content type="text"><![CDATA[简介Spring Cloud提供了开发分布式微服务系统的一些常用组件，例如服务注册和发现、配置中心、熔断器、智能路由、微代理、控制总线、全局锁、分布式会话等。 常用组件 服务注册和发现组件Eureka 可以轻松的实现服务注册与发现功能，另外Spring Cloud 也支持Consul和Zookeeper，用于服务注册与发现 熔断组件Hystrix 除了基本的熔断器功能，还能实现服务降级、服务限流的功能 负载均衡组件Ribbon 通常和Eureka、Zuul、RestTemplate、Feign配合使用。Ribbon和Zuul配合，很容易实现负载均衡；Ribbon和RestTemplate、Feign配合，在消费服务时能够做到负载均衡。 路由网关Zuul Zuul有智能路由和过滤的功能 上述四个组件都来自Netflix的公司，统称为Spring Cloud Netflix Spring Cloud Config 提供了配置文件统一管理的功能，包括Server端和Client端，Server端读取本地仓库或远程仓库的配置文件，Client向Server端读取配置信息 Spring Cloud Sleuth 分布式链路追踪组件]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>spring cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习docker中遇到的问题]]></title>
    <url>%2F2018%2F08%2F03%2Fdocker-error%2F</url>
    <content type="text"><![CDATA[yaml: line 1: mapping values are not allowed in this context按照官网入门教程的第三部分执行到docker stack deploy -c docker-compose.yml getstartedlab，会出现这个错误，那是因为yaml的语法格式有问题，部分地方少了空格补上就好。yml在线错误校验https://www.bejson.com/validators/yaml/参考博客：https://blog.csdn.net/kuangay/article/details/80662914]]></content>
      <categories>
        <category>容器</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux下java的安装]]></title>
    <url>%2F2018%2F07%2F16%2Flinux-java-install%2F</url>
    <content type="text"><![CDATA[Linux下java的安装基本环境Linux: CentOS Linux release 7.5.1804 (Core)Java: java version “10.0.1” 下载java首先进入oracle官网找到你需要下载的java版本:http://www.oracle.com/technetwork/java/javase/downloads/index.html我这里一jdk10为例，在linux下执行以下命令即可下载: wget http://download.oracle.com/otn-pub/java/jdk/10.0.1+10/fb4372174a714e6b8c52526dc134031e/jdk-10.0.1_linux-x64_bin.tar.gz 如果提示wget未找到命令则执行: yum install wget -ywget http://download.oracle.com/otn-pub/java/jdk/10.0.1+10/fb4372174a714e6b8c52526dc134031e/jdk-10.0.1_linux-x64_bin.tar.gz 解压javatar xzvf jdk-10.0.1_linux-x64_bin.tar.gz 配置环境变量打开profile vi /etc/profile 按i编辑,在文件末尾加上 export JAVA_HOME=jdk-10.0.1export PATH=$JAVA_HOME/bin:$PATH 首先按esc退出insert模式，然后输入##:wq##保存文件最后执行: source /etc/profile 测试配置是否生效输入: java -version 输出： [root@localhost /]# java -versionjava version “10.0.1” 2018-04-17Java(TM) SE Runtime Environment 18.3 (build 10.0.1+10)Java HotSpot(TM) 64-Bit Server VM 18.3 (build 10.0.1+10, mixed mode)]]></content>
      <tags>
        <tag>linux</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring注解-注册bean的几种方式]]></title>
    <url>%2F2018%2F07%2F11%2Fspring-annotation03%2F</url>
    <content type="text"><![CDATA[前言在spring中注册bean有多种方式： 包扫描+组件标注注解（@Controller/@Service/@Repository/@Component）[自己写的类] @Bean[导入的第三方包里面的组件] @Import[快速给容器中导入一个组件] @Import(要导入到容器中的组件)；容器中就会自动注册这个组件，id默认是全类名 ImportSelector:返回需要导入的组件的全类名数组； ImportBeanDefinitionRegistrar:手动注册bean到容器中 使用Spring提供的 FactoryBean（工厂Bean）; 默认获取到的是工厂bean调用getObject创建的对象 要获取工厂Bean本身，我们需要给id前面加一个&amp; 包扫描与@Bean注解前面章节中已经提过不再概述 @Import注解基本使用@Import( {类名.class} )例：@Import( {Color.class,Red.class} ) ImportSelectorImportSelector是@Import的一个参数，该注解在spring boot中大量使用，使用ImportSelector，首先要实现ImportSelector接口1234567891011121314//自定义逻辑返回需要导入的组件public class MyImportSelector implements ImportSelector &#123; //返回值，就是到导入到容器中的组件全类名 //AnnotationMetadata:当前标注@Import注解的类的所有注解信息 @Override public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123; // TODO Auto-generated method stub //importingClassMetadata //方法不要返回null值 return new String[]&#123;"com.yhzl.bean.Blue","com.yhzl.bean.Yellow"&#125;; &#125;&#125; 使用方法： @Import( {MyImportSelector.class} ) ImportBeanDefinitionRegistrar实现ImportBeanDefinitionRegistrar接口：1234567891011121314151617181920212223public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar &#123; /** * AnnotationMetadata：当前类的注解信息 * BeanDefinitionRegistry:BeanDefinition注册类； * 把所有需要添加到容器中的bean；调用 * BeanDefinitionRegistry.registerBeanDefinition手工注册进来 */ @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123; boolean definition = registry.containsBeanDefinition("com.yhzl.bean.Red"); boolean definition2 = registry.containsBeanDefinition("com.yhzl.bean.Blue"); //当Red和Blue都被spring注册时，将注册RainBow if(definition &amp;&amp; definition2)&#123; //指定Bean定义信息；（Bean的类型，Bean。。。） RootBeanDefinition beanDefinition = new RootBeanDefinition(RainBow.class); //注册一个Bean，指定bean名 registry.registerBeanDefinition("rainBow", beanDefinition); &#125; &#125;&#125; 使用方法： @Import( {MyImportBeanDefinitionRegistrar.class} ) FactoryBean使用FactoryBean，首先要实现spring的org.springframework.beans.factory.FactoryBean接口12345678910111213141516171819202122232425262728293031package com.atguigu.bean;import org.springframework.beans.factory.FactoryBean;//创建一个Spring定义的FactoryBeanpublic class ColorFactoryBean implements FactoryBean&lt;Color&gt; &#123; //返回一个Color对象，这个对象会添加到容器中 @Override public Color getObject() throws Exception &#123; // TODO Auto-generated method stub System.out.println("ColorFactoryBean...getObject..."); return new Color(); &#125; @Override public Class&lt;?&gt; getObjectType() &#123; // TODO Auto-generated method stub return Color.class; &#125; //是单例？ //true：这个bean是单实例，在容器中保存一份 //false：多实例，每次获取都会创建一个新的bean； @Override public boolean isSingleton() &#123; // TODO Auto-generated method stub return false; &#125;&#125; 配置类：123456// 注：该方法返回的的是FactoryBean的getObject()方法所返回的对象，并发工厂本身// 若有想获取工厂本身在获取时需要加上&amp;@Beanpublic ColorFactoryBean colorFactoryBean()&#123; return new ColorFactoryBean();&#125;]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring注解(1)]]></title>
    <url>%2F2018%2F07%2F11%2Fspring-annotation02%2F</url>
    <content type="text"><![CDATA[@ComponentScan@ComponentScan使用@Repeatable标识，在jdk1.8中可重复标注，在1.8以下版本中可使用@ComponentScans达到同样效果 value@ComponentScan value:指定要扫描的包 例：@ComponentScan(value = “com.yhzl”) excludeFilters和includeFiltersexcludeFilters = Filter[] ：指定扫描的时候按照什么规则排除那些组件includeFilters = Filter[] ：指定扫描的时候只需要包含哪些组件 例：includeFilters = { @Filter(type = FilterType.ANNOTATION, classes = { Controller.class }) } 参数typeFilterType.ANNOTATION：按照注解FilterType.ASSIGNABLE_TYPE：按照给定的类型FilterType.ASPECTJ：使用ASPECTJ表达式FilterType.REGEX：使用正则指定FilterType.CUSTOM：使用自定义规则 自定义过滤规则自定义过滤规则需要实现TypeFilter接口首先在配置类的excludeFilters或includeFilters中标注 @Filter(type=FilterType.CUSTOM,classes={类名.class}) 实现TypeFilter接口12345678910111213141516171819202122232425262728293031323334353637package com.yhzl.config;import java.io.IOException;import org.springframework.core.io.Resource;import org.springframework.core.type.AnnotationMetadata;import org.springframework.core.type.ClassMetadata;import org.springframework.core.type.classreading.MetadataReader;import org.springframework.core.type.classreading.MetadataReaderFactory;import org.springframework.core.type.filter.TypeFilter;public class MyTypeFilter implements TypeFilter &#123; /** * metadataReader：读取到的当前正在扫描的类的信息 * metadataReaderFactory:可以获取到其他任何类信息的 */ @Override public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException &#123; // TODO Auto-generated method stub //获取当前类注解的信息 AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata(); //获取当前正在扫描的类的类信息 ClassMetadata classMetadata = metadataReader.getClassMetadata(); //获取当前类资源（类的路径） Resource resource = metadataReader.getResource(); //获取类名 String className = classMetadata.getClassName(); System.out.println("---&gt;"+className); if(className.contains("er"))&#123; return true; &#125; return false; &#125;&#125; @Scope@Scope:调整作用域，默认值为：singletonprototype：多实例的：ioc容器启动并不会去调用方法创建对象放在容器中。每次获取的时候才会调用方法创建对象；singleton：单实例的（默认值）：ioc容器启动会调用方法创建对象放到ioc容器中。以后每次获取就是直接从容器（map.get()）中拿，request：同一次请求创建一个实例session：同一个session创建一个实例 @Lazy懒加载：单实例bean：默认在容器启动的时候创建对象；懒加载：容器启动不创建对象。第一次使用(获取)Bean创建对象，并初始化； @Conditional@Conditional按条件注册bean，既可标注在类上也可标注在方法上，参数为Condition的实现类Condition的实现类12345678910111213141516171819202122232425262728293031323334353637383940package com.yhzl.condition;import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;import org.springframework.beans.factory.support.BeanDefinitionRegistry;import org.springframework.context.annotation.Condition;import org.springframework.context.annotation.ConditionContext;import org.springframework.core.env.Environment;import org.springframework.core.type.AnnotatedTypeMetadata;//判断是否linux系统public class LinuxCondition implements Condition &#123; /** * ConditionContext：判断条件能使用的上下文（环境） * AnnotatedTypeMetadata：注释信息 */ @Override public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123; // TODO是否linux系统 //1、能获取到ioc使用的beanfactory ConfigurableListableBeanFactory beanFactory = context.getBeanFactory(); //2、获取类加载器 ClassLoader classLoader = context.getClassLoader(); //3、获取当前环境信息 Environment environment = context.getEnvironment(); //4、获取到bean定义的注册类 BeanDefinitionRegistry registry = context.getRegistry(); //获取当前系统名称 String property = environment.getProperty("os.name"); //可以判断容器中的bean注册情况，也可以给容器中注册bean boolean definition = registry.containsBeanDefinition("person"); if(property.contains("linux"))&#123; return true; &#125; return false; &#125;&#125; 配置类12345@Conditional(LinuxCondition.class) @Bean("linus") public Person person02()&#123; return new Person("linus", 48); &#125;]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring注解-Hello World]]></title>
    <url>%2F2018%2F07%2F10%2Fspring-annotation01%2F</url>
    <content type="text"><![CDATA[使用java类代替传统的xml传统配置 1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.3.xsd"&gt; &lt;bean id="person" class="com.yhzl.bean.Person" scope="prototype" &gt; &lt;property name="age" value="18"&gt;&lt;/property&gt; &lt;property name="name" value="zhangsan"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; java配置类1234567891011//配置类==配置文件@Configurationpublic class MainConfig &#123; //给容器中注册一个Bean;类型为返回值的类型，id默认是用方法名作为id @Bean("person") public Person person01()&#123; return new Person("lisi", 20); &#125;&#125; 实体类12345678910111213141516171819202122232425262728293031323334353637public class Person &#123; private String name; private Integer age; private String nickName; public String getNickName() &#123; return nickName; &#125; public void setNickName(String nickName) &#123; this.nickName = nickName; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public Person(String name, Integer age) &#123; super(); this.name = name; this.age = age; &#125; public Person() &#123; super(); // TODO Auto-generated constructor stub &#125; @Override public String toString() &#123; return "Person [name=" + name + ", age=" + age + ", nickName=" + nickName + "]"; &#125; 测试类1234567891011121314151617181920public class MainTest &#123; public static void main(String[] args) &#123;// 传统方式// ApplicationContext applicationContext = new ClassPathXmlApplicationContext("beans.xml");// Person bean = (Person) applicationContext.getBean("person");// System.out.println(bean); ApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig.class); Person bean = applicationContext.getBean(Person.class); System.out.println(bean); // 通过类型获取beanName String[] namesForType = applicationContext.getBeanNamesForType(Person.class); for (String name : namesForType) &#123; System.out.println(name); &#125; &#125;&#125; 注解说明@Configuration 告诉Spring这是一个配置类 @Bean 等同于传统xml的标签，id默认为方法名，若想改变id可给@Bean注解传入参数，如：@Bean(“person”)]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下nginx的安装]]></title>
    <url>%2F2018%2F07%2F06%2Fnginx01%2F</url>
    <content type="text"><![CDATA[遇到的问题the HTTP rewrite module requires the PCRE library error: the HTTP rewrite module requires the PCRE library.You can either disable the module by using –without-http_rewrite_moduleoption, or install the PCRE library into the system, or build the PCRE librarystatically from the source with nginx by using –with-pcre= option. 解决方案： yum -y install pcre-devel the HTTP gzip module requires the zlib library error: the HTTP gzip module requires the zlib library.You can either disable the module by using –without-http_gzip_moduleoption, or install the zlib library into the system, or build the zlib librarystatically from the source with nginx by using –with-zlib= option. 解决方案： yum install -y zlib-devel nginx的下载及安装官网12345678910// 下载wget http://nginx.org/download/nginx-1.14.0.tar.gz// 解压tar xzvf nginx-1.14.0.tar.gz// 进入 nginx-1.14.0目录cd nginx-1.14.0// 安装./configuremakemake install 启动nginx进入安装目录，默认为/usr/local/nginx ./sbin/nginx 停止nginx nginx -s stop 重启nginx nginx -s reload]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[连接redis]]></title>
    <url>%2F2018%2F06%2F28%2Fredis01%2F</url>
    <content type="text"><![CDATA[遇到的问题无法连接上redis使用redis-cli可以正常使用redis，但是在Windows中使用python连不上，这就很烦躁，没办法只能靠百度了1.可能是端口未开放使用该命令开放端口1firewall-cmd --zone=public --add-port=6379/tcp --permanent 2.修改redis.conf配置 将bind 127.0.0.1 改为 bind 0.0.0.0将protected-mode yes 改为 protected-mode no 安装python的redis模块 pip install redis python连接redis12345import redisconn = redis.StrictRedis(host='ip地址', password='密码')conn.set('test', 'test1')print(conn.get('test')) java连接redispom.xml12345678&lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; java代码1234567891011121314package com.yhzl.dao01.redis;import redis.clients.jedis.Jedis;public class RedisDay01 &#123; public static void main(String[] args) &#123; Jedis jedis = new Jedis("ip地址"); jedis.auth("密码"); jedis.set("test1", "test1"); System.out.println(jedis.get("test1")); &#125; &#125; 参考博客虚拟机安装Redis后无法连接问题的处理redis的配置（安装、启动、本机与虚拟机的redis的连接）redis使用密码登录]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>nosql</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下redis的安装]]></title>
    <url>%2F2018%2F06%2F28%2Finstall-redis%2F</url>
    <content type="text"><![CDATA[遇到的问题本次安装redis过程中遇到了不少问题在此一一记录下来！！！ yum出现Could not retrieve mirrorlist出现该问题一般是由于网络有问题，具体解决方案参照https://blog.csdn.net/gebitan505/article/details/54584213 wget未找到命令解决方案：https://blog.csdn.net/djj_alice/article/details/80407769 jemalloc/jemalloc.h：没有那个文件或目录解决方案：https://blog.csdn.net/honchou56/article/details/53994708 make后报错安装gcc，解决方案：https://yq.aliyun.com/articles/238783 版本Linux版本： CentOS Linux release 7.5.1804 (Core)Redis版本： 4.0.10 64位 redis的下载进入该页面https://redis.io/download找到Installation，按照步骤来即可完成安装。 redis的启动 src/redis-server &amp; 注意后面要加一个&amp;，否则ctrl+c会关闭redis，&amp;代表后台运行然后执行 src/redis-cli 即可进入redis]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>nosql</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven]]></title>
    <url>%2F2018%2F05%2F27%2Fmaven%2F</url>
    <content type="text"><![CDATA[官网下载mavenhttps://maven.apache.org/download.cgi 解压并进入conf双击setting.xml将maven中央仓库改为阿里云的，在mirrors节点下添加如下代码123456&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 将jdk版本改为1.8，在profiles节点下添加如下代码123456789101112&lt;profile&gt; &lt;id&gt;jdk18&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;/profile&gt; 配置eclipse找到以下目录 Window-&gt;Preferences-&gt;maven-&gt;User Settings 将User Settings的路径更改为刚刚配置的setting.xml的路径]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zteoa项目]]></title>
    <url>%2F2018%2F05%2F27%2Fteam-zteoa%2F</url>
    <content type="text"><![CDATA[初始化项目项目地址：https://github.com/chsm1998/team_zteoa.git 方法一：使用git clone命令拷贝然后导入eclipse1git clone https://github.com/chsm1998/team_zteoa.git 方法二：首先找到Git Repositories点击之后下方将出现 然后点击出现该框后一直next就好了 拷贝完项目后点击import projects 完成后应该有如下目录 项目要求数据库新建用户 用户名为:three,密码为:team参考链接 注意事项 禁止向leader分支提交代码 禁止修改公共配置文件 禁止改动他人代码，若需要使用接口，请与模块负责人联系，不得直接更改他人模块 每个类需注明编写人、编写时间，对于接口方法需编写注释指明接口作用 其他细则参照团队开发]]></content>
      <categories>
        <category>团队</category>
      </categories>
      <tags>
        <tag>team</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring-mvc的疑惑(持续更新)]]></title>
    <url>%2F2018%2F05%2F12%2Fspring-mvc%2F</url>
    <content type="text"><![CDATA[1.@SessionAttribute注解以下是官方文档的解释： If you need access to pre-existing session attributes that are managed globally, i.e. outside the controller (e.g. by a filter), and may or may not be present use the @SessionAttribute annotation on a method parameter: 关键在于and may or may not be present翻译过来是:可能存在也可能不存在而在实际使用时若session无法获取到该属性是会报400错误的： Missing session attribute ‘user’ of type User 2.@RequestBody关于该注解还是由于自己底层知识不够造成的，昨天在编写代码的过程中发现会报一个Stream close的错误，想尝试Debug发现根本没进入自己写的方法，然后就是各种百度，依旧没找到答案……没办法有bug也得解决啊，既然没进入方法肯定是spring mvc赋值时的问题呗，然后一个一个删参数，发现当参数中有两个@RequestBody时会发生这个错误，后来一想也是一次请求怎么可能会有两个请求体呢？后来的解决方法是利用map结束值，然后再手动赋值给对象]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>spring mvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用mybatis中遇到的一些坑(持续更新)]]></title>
    <url>%2F2018%2F04%2F05%2Fmybatis-error%2F</url>
    <content type="text"><![CDATA[当xxxMapper的方法需要多个参数时，引发的异常方法： User getUser(Integer id, String username); xml配置:123&lt;select id="getUser" resultType="user"&gt; select * from User where id = #&#123;id&#125; and username = #&#123;username&#125;&lt;/select&gt; 此时若调用getUser方法会抛出一个异常： Cause: org.apache.ibatis.binding.BindingException: Parameter ‘id’ not found. Available parameters are [arg1, arg0, param1, param2] 造成原因： 由于mybatis会自动将参数封装成一个map，该map的key默认为param+参数位置，所以此时用id和username取值会报错 解决办法：123&lt;select id="getUser" resultType="user"&gt; select * from User where id = #&#123;param1&#125; and username = #&#123;param2&#125;&lt;/select&gt; 如果非要用#{id}和#{username}怎么办？加上@Param注解1User getUser(@Param("id")Integer id, @Param("username")String username); 当然这种解决办法让人感觉还是很麻烦，有没有简单一点的方式呢？ 直接传入一个pojo对象 例： User getUser(User user); 若没有pojo怎么办？直接传入map 例： User getUser(Map&lt;Object, Object&gt; map);]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>mybatis</tag>
        <tag>error</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis03--xml映射文件]]></title>
    <url>%2F2018%2F04%2F05%2Fmybatis03%2F</url>
    <content type="text"><![CDATA[select使用非常简单：123&lt;select id="selectPerson" parameterType="int" resultType="hashmap"&gt; SELECT * FROM PERSON WHERE ID = #&#123;id&#125;&lt;/select&gt; 下面讲一下其中常用的属性： id 唯一标识符 parameterType 传入的参数类型，该属性是可选的，mybatis会自动推断 resultType 返回值类型，不能与resultMap同时使用 resultMap 外部 resultMap 的命名引用关于resultType和resultMap特别说明一下，官方给出的说明特别简短，具体两者有什么不同到时候在实际使用中再说 insert, update 和 delete与select差不多这里把几个不同的属性说一下: useGeneratedKeys （仅对 insert 和 update 有用）默认值为false，当为true时会从数据库中取出自动增长的主键值，并将值返回 keyProperty （仅对 insert 和 update 有用）MyBatis 会通过 getGeneratedKeys 的返回值或者通过 insert 语句的 selectKey 子元素设置它的键值 例：123456789101112&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="org.mybatis.example.BlogMapper"&gt; &lt;select id="selectUser" resultType="com.yhzl.bean.User"&gt; select * from User where id = #&#123;id&#125; &lt;/select&gt; &lt;insert id="insertUser" useGeneratedKeys="true" keyProperty="id"&gt; insert into User (username, password) values (#&#123;username&#125;, #&#123;password&#125;) &lt;/insert&gt;&lt;/mapper&gt; 12345678910111213141516171819202122232425262728293031323334package com.yhzl.test;import java.io.IOException;import java.io.InputStream;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import com.yhzl.bean.User;/** * @author chsm * @date 2018年4月4日上午8:33:13 * @version 1.0 */public class Test &#123; public static void main(String[] args) throws IOException &#123; InputStream inputStream = Resources.getResourceAsStream("mybatis-config.xml"); SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession session = sessionFactory.openSession(); User user2 = new User(); user2.setUsername("abcdefg"); user2.setPassword("abcdefg"); int i = session.insert("org.mybatis.example.BlogMapper.insertUser", user2); session.commit(); session.close(); //当设置useGeneratedKeys="true" keyProperty="id"时User有id值，若不设置则没有id值 System.out.println(user2); &#125; &#125; sql这个元素可以被用来定义可重用的 SQL 代码段，可以包含在其他语句中。它可以被静态地(在加载参数) 参数化. 不同的属性值通过包含的实例变化. 比如：1&lt;sql id="userColumns"&gt; $&#123;alias&#125;.id,$&#123;alias&#125;.username,$&#123;alias&#125;.password &lt;/sql&gt; 这个 SQL 片段可以被包含在其他语句中，例如：1234567&lt;select id="selectUsers" resultType="map"&gt; select &lt;include refid="userColumns"&gt;&lt;property name="alias" value="t1"/&gt;&lt;/include&gt;, &lt;include refid="userColumns"&gt;&lt;property name="alias" value="t2"/&gt;&lt;/include&gt; from some_table t1 cross join some_table t2&lt;/select&gt; SQL中也可以使用include，例如：1234567891011121314151617&lt;sql id="sometable"&gt; $&#123;prefix&#125;Table&lt;/sql&gt;&lt;sql id="someinclude"&gt; from &lt;include refid="$&#123;include_target&#125;"/&gt;&lt;/sql&gt;&lt;select id="select" resultType="map"&gt; select field1, field2, field3 &lt;include refid="someinclude"&gt; &lt;property name="prefix" value="Some"/&gt; &lt;property name="include_target" value="sometable"/&gt; &lt;/include&gt;&lt;/select&gt; 后面章节对于后面章节推荐大家前往官网观看附上链接：http://www.mybatis.org/mybatis-3/zh/sqlmap-xml.html#Parameters]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis02--xml配置文件]]></title>
    <url>%2F2018%2F04%2F04%2Fmybatis02%2F</url>
    <content type="text"><![CDATA[properties可以用来设置属性1234&lt;properties resource="org/mybatis/example/config.properties"&gt; &lt;property name="username" value="dev_user"/&gt; &lt;property name="password" value="F2Fa3!33TYyg"/&gt;&lt;/properties&gt; 然后就可以使用配置的属性啦123456&lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;driver&#125;"/&gt; &lt;property name="url" value="$&#123;url&#125;"/&gt; &lt;property name="username" value="$&#123;username&#125;"/&gt; &lt;property name="password" value="$&#123;password&#125;"/&gt;&lt;/dataSource&gt; 当然properties也可以由java代码来配置12//传入MyBatis配置文件和属性配置文件SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, props); 如果三者混合使用会出现什么情况呢？这里引用MyBatis官方的解释 在 properties 元素体内指定的属性首先被读取。 然后根据 properties 元素中的 resource 属性读取类路径下属性文件或根据 url 属性指定的路径读取属性文件，并覆盖已读取的同名属性。 最后读取作为方法参数传递的属性，并覆盖已读取的同名属性。 简单的说就是java代码&gt;外部配置&gt;内部配置从MyBatis3.4.2开始可以为占位符指定默认值了，附上官方案例：1234&lt;dataSource type="POOLED"&gt; &lt;!-- 当username不存在时,值就会使用ut_user代替 --&gt; &lt;property name="username" value="$&#123;username:ut_user&#125;"/&gt;&lt;/dataSource&gt; 不过该特性默认情况下是关闭的需手动开启：123&lt;properties resource="org/mybatis/example/config.properties"&gt; &lt;property name="org.apache.ibatis.parsing.PropertyParser.enable-default-value" value="true"/&gt; &lt;!-- Enable this feature --&gt;&lt;/properties&gt; settings该属性比较多，在这里就不详述了，有需要的可以看官方文档:http://www.mybatis.org/mybatis-3/zh/configuration.html#settings typeAliases该属性用于给类设置别名例：12345678&lt;typeAliases&gt; &lt;typeAlias alias="Author" type="domain.blog.Author"/&gt; &lt;typeAlias alias="Blog" type="domain.blog.Blog"/&gt; &lt;typeAlias alias="Comment" type="domain.blog.Comment"/&gt; &lt;typeAlias alias="Post" type="domain.blog.Post"/&gt; &lt;typeAlias alias="Section" type="domain.blog.Section"/&gt; &lt;typeAlias alias="Tag" type="domain.blog.Tag"/&gt;&lt;/typeAliases&gt; 当需要使用某个类时就不需要写包名+类名啦，直接使用别名就可以了还可以指定包名，这样MyBatis就会扫描该包下的所有类，若没加注解标识则默认别名为类名小写123&lt;typeAliases&gt; &lt;package name="domain.blog"/&gt;&lt;/typeAliases&gt; 若有注解，则别名为注解所设定的值1234@Alias("Author")public class Author &#123; ...&#125; 对于typeHandlers、objectFactory、plugins这三个标签我们以后再分析 environments(配置环境)environment在MyBatis中允许配置多个环境例：123456789101112131415161718192021222324&lt;environments default="aaa"&gt; &lt;environment id="aaa"&gt; &lt;transactionManager type="JDBC"&gt; &lt;property name="..." value="..."/&gt; &lt;/transactionManager&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;driver&#125;"/&gt; &lt;property name="url" value="$&#123;url&#125;"/&gt; &lt;property name="username" value="$&#123;username&#125;"/&gt; &lt;property name="password" value="$&#123;password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;environment id="bbb"&gt; &lt;transactionManager type="JDBC"&gt; &lt;property name="..." value="..."/&gt; &lt;/transactionManager&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;driver&#125;"/&gt; &lt;property name="url" value="$&#123;url&#125;"/&gt; &lt;property name="username" value="$&#123;username&#125;"/&gt; &lt;property name="password" value="$&#123;password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; environments中设置default代表默认选择的环境，如果要默认选择bbb把default改成bbb就好了在MyBatis中一个SqlSessionFactory只能与一个环境所绑定如果不希望MyBatis绑定默认环境可以使用12//传入参数为MyBatis配置和环境id 注：environment为String类型SqlSessionFactoryBuilder().build(reader, environment); transactionManager(事物管理器)MyBatis有两种事物管理器，也就是说transactionManager的type值不能随意写，它只有两个值那就是type=”[JDBC|MANAGED]”官方解释： JDBC – 这个配置就是直接使用了 JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域。 MANAGED – 这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将 closeConnection 属性设置为 false 来阻止它默认的关闭行为。例如:123&lt;transactionManager type="MANAGED"&gt; &lt;property name="closeConnection" value="false"/&gt;&lt;/transactionManager&gt; 一般情况下type值都是JDBC 注： 如果你正在使用 Spring + MyBatis，则没有必要配置事务管理器， 因为 Spring 模块会使用自带的管理器来覆盖前面的配置。 dataSource(数据源)type同样是一个枚举值,它的值可以为UNPOOLED、POOLED、JNDI，默认情况下写POOLED就好了关于三个枚举值的含义大家可以去官网查看，由于太长了在这里就不贴出来了。 mappers(映射器)在MyBatis中配置映射有四种方式：123456&lt;!-- 使用相对于类路径的资源引用 --&gt;&lt;mappers&gt; &lt;mapper resource="org/mybatis/builder/AuthorMapper.xml"/&gt; &lt;mapper resource="org/mybatis/builder/BlogMapper.xml"/&gt; &lt;mapper resource="org/mybatis/builder/PostMapper.xml"/&gt;&lt;/mappers&gt; 123456&lt;!-- 使用完全限定资源定位符（URL） --&gt;&lt;mappers&gt; &lt;mapper url="file:///var/mappers/AuthorMapper.xml"/&gt; &lt;mapper url="file:///var/mappers/BlogMapper.xml"/&gt; &lt;mapper url="file:///var/mappers/PostMapper.xml"/&gt;&lt;/mappers&gt; 123456&lt;!-- 使用映射器接口实现类的完全限定类名 --&gt;&lt;mappers&gt; &lt;mapper class="org.mybatis.builder.AuthorMapper"/&gt; &lt;mapper class="org.mybatis.builder.BlogMapper"/&gt; &lt;mapper class="org.mybatis.builder.PostMapper"/&gt;&lt;/mappers&gt; 1234&lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt;&lt;mappers&gt; &lt;package name="org.mybatis.builder"/&gt;&lt;/mappers&gt;]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis01--初识MyBatis]]></title>
    <url>%2F2018%2F04%2F03%2Fmybatis01%2F</url>
    <content type="text"><![CDATA[近日要开始MyBatis的学习了，首先第一件事当然是看官方文档啦 附上官方文档http://www.mybatis.org/mybatis-3/zh/index.html 创建maven工程名称任意，创一个最简单的maven工程就好了 引入MyBatis在pom.xml中加入MyBatis依赖和数据库驱动，我这里用的是mysql1234567891011&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;x.x.x&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.46&lt;/version&gt;&lt;/dependency&gt; x.x.x填的是MyBatis的版本号，目前最新稳定版是3.4.6 编写配置文件由xml构建SqlSessionFactory,首先编写XML配置，以下所有中文均改成自己的配置1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="数据库驱动"/&gt; &lt;property name="url" value="url地址"/&gt; &lt;property name="username" value="用户名"/&gt; &lt;property name="password" value="密码"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource="mapper路径"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 编写mapper配置文件：123456789&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="org.mybatis.example.BlogMapper"&gt; &lt;select id="selectUser" resultType="com.yhzl.bean.User"&gt; select * from User where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 编写实体类及测试类实体类：1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.yhzl.bean;/** * @author chsm * @date 2018年4月4日上午8:30:32 * @version 1.0 */public class User &#123; private Integer id; private String username; private String password; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString() &#123; return "User [id=" + id + ", username=" + username + ", password=" + password + "]"; &#125;&#125; 测试类:12345678910111213141516171819202122232425262728package com.yhzl.test;import java.io.IOException;import java.io.InputStream;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import com.yhzl.bean.User;/** * @author chsm * @date 2018年4月4日上午8:33:13 * @version 1.0 */public class Test &#123; public static void main(String[] args) throws IOException &#123; InputStream inputStream = Resources.getResourceAsStream("mybatis-config.xml"); SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession session = sessionFactory.openSession(); User user = session.selectOne("org.mybatis.example.BlogMapper.selectUser", 1); System.out.println(user); &#125; &#125; 对代码的编写已经完成了此时可以运行了，如果出现报错等情况，请检查下代码看看有没有写错]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[team]]></title>
    <url>%2F2018%2F04%2F03%2Fteam%2F</url>
    <content type="text"><![CDATA[团队协作要求统一开发环境版本： eclipse4.7.3tomcat8.5java8(细节版本待定) 开发所需条件 1.下载并安装git2.注册github账号3.掌握git基本命令，能独立完成远程仓库的提交及clone4.掌握makedown基本语法，编写文档 开发注意事项 不得强制提交带有冲突的项目不得使用与团队不一致的开发环境每次提交需注明新增功能，，并更新md文件在md文件夹下新建人名.md,编写详细的更新文档 团队协作流程 1.组长分配任务并初始化项目提交至远程仓库2.组员从远程仓库clone项目导入eclipse进行开发3.每天21点前将代码提交至远程仓库4.每天24点前组长对项目进行整合纠错并提交至远程仓库 附录git官网github官网MarkDown文档git教程注: git教程无需完整看完掌握基本使用方法即可]]></content>
      <categories>
        <category>团队</category>
      </categories>
      <tags>
        <tag>team</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot(2)--spring boot集成swagger2]]></title>
    <url>%2F2018%2F04%2F03%2Fspring-boot2%2F</url>
    <content type="text"><![CDATA[swagger2是什么？简单来说swagger2是一个可以帮你更好的测试REST风格的API插件 什么是REST风格？传统的请求URL是http://www.test.com/getUser?userId=1REST风格的URL是http://www.test.com/getUser/1百度百科解释 环境Windows10 家庭版Spring Boot 2.0eclipse4.7.3jdk1.8 spring boot集成swagger2初始化项目此次初始化用到了Spring插件，没有插件的直接创建maven工程就好了首先右键新建项目选择other，然后找到Spring Boot下的Spring Starter Project,选中然后点击next点击next后请确保电脑网络异常，因为要通过网络加载配置name处可更改项目名称，在这里我就不改了，继续点击next然后选中以下几项，如果不需要数据库，可不勾选sql下的组件然后点击finish 添加swagger2依赖此时一个Spring Boot项目就算初始化成功了，这时候我们来配置pom.xml加入swagger2和swagger ui依赖123456789101112&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt;&lt;/dependency&gt; 编写实体类及配置信息现在我们来编写一个实体类User:12345678910111213141516171819202122232425package com.example.demo.bean;public class User &#123; private Integer id; private String username; private String password; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; 编写mapper:1234567891011121314package com.example.demo.mapper;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Select;import com.example.demo.bean.User;@Mapperpublic interface UserMapper &#123; @Select("SELECT * FROM User WHERE id=#&#123;id&#125;") User getUser(Integer id);&#125; 编写controller:123456789101112131415161718192021222324package com.example.demo.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import com.example.demo.bean.User;import com.example.demo.mapper.UserMapper;@Controllerpublic class UserController &#123; @Autowired private UserMapper userMapper; @ResponseBody @RequestMapping("/user/&#123;id&#125;") public User getUser(@PathVariable("id") Integer id) &#123; return userMapper.getUser(id); &#125;&#125; 在resource的application.properties中加入数据库配置信息:123spring.datasource.url=数据库地址spring.datasource.username=数据库用户名spring.datasource.password=数据库密码 在测试类中添加一个@EnableSwagger2注解123456789101112131415package com.example.demo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import springfox.documentation.swagger2.annotations.EnableSwagger2;@EnableSwagger2@SpringBootApplicationpublic class Demo1Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Demo1Application.class, args); &#125;&#125; 启动Spring Boot验证是否成功启动Spring Boot然后访问localhost:8080/swagger-ui.html此时若出现以下画面即代表启动成功这时候我们可以测试下，点击user-controller然后再点击GET测试成功结果：]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot(1)--初识spring boot]]></title>
    <url>%2F2018%2F04%2F02%2Fspring-boot1%2F</url>
    <content type="text"><![CDATA[今天对着视频尝试着写了一下Spring Boot，下面说一下感受与问题 感受 不得不说Spring Boot真的是十分好用啊，总的来说就是配置简单， 启动快速， 极易上手 环境Windows10 家庭版Spring Boot 2.0eclipse4.7.3jdk1.8 配置首先新建一个maven工程，然后将以下几行代码复制到pom.xml中1234567891011&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.0.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 这时候maven基本就配置好了，接下来我们来写java代码，首先新建一个类名称任意，然后写一个main方法，如果安装了Spring插件的话，eclipse会有两个main方法提示这时候选第二个就好了对于没有安装插件的朋友只需要这样写main方法就好了,注意当中的SampleController.class,要改成类名.class123public static void main(String[] args) throws Exception &#123; SpringApplication.run(SampleController.class, args); &#125; 然后在类上加上@SpringBootApplication注解就好了，这个时候Spring Boot就可以跑起来了完整代码：123456@SpringBootApplicationpublic class SampleController &#123; public static void main(String[] args) throws Exception &#123; SpringApplication.run(SampleController.class, args); &#125;&#125; 然后我们就可以在浏览器输入localhost:8080访问了访问成功的页面是这样的：这时候我们就可以开始编写Controller，让Spring Boot显示出Hello Spring Boot了Controller的编写也很简单这里就直接附上代码了：12345678@Controllerpublic class HelloController &#123; @ResponseBody @RequestMapping("/hello") public String hello() &#123; return "Hello Spring Boot"; &#125;&#125; 这时候再重启服务器访问localhost:8080/hello浏览器就会显示Hello Spring Boot啦成功界面：当然大家也可以直接按照官方的例子，编写Spring Boot程序：123456789101112131415161718192021package hello;import org.springframework.boot.*;import org.springframework.boot.autoconfigure.*;import org.springframework.stereotype.*;import org.springframework.web.bind.annotation.*;@Controller@EnableAutoConfigurationpublic class SampleController &#123; @RequestMapping("/") @ResponseBody String home() &#123; return "Hello World!"; &#125; public static void main(String[] args) throws Exception &#123; SpringApplication.run(SampleController.class, args); &#125;&#125; 最后附上Spring Boot的官网和文档 Spring Boot官网：https://projects.spring.io/spring-boot/官方文档：https://docs.spring.io/spring-boot/docs/2.0.0.RELEASE/reference/htmlsingle/]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello, Hexo]]></title>
    <url>%2F2018%2F03%2F30%2Fhello-Hexo%2F</url>
    <content type="text"><![CDATA[刚搭建好博客，第一篇博客就说一下如何配置Hexo到GitHub吧！ 我的环境是Windows10 家庭版 64位 安装node.js和gitnode的安装说实话具体的安装步骤我已经忘了，因为很久前我就安装了，估计也就一直下一步就好了，在这里给出下载链接，如果安装过程中出现问题的话，请各位自行百度解决下 以下是安装成功的样子 git的安装git下载地址,我安装的时候是一直下一步就好了 安装成功后在空白处单击右键会出现以下两个图标 注册GitHub并新建项目注册没什么好说的直接到GitHub官网注册就好新建项目时注意项目名必须是用户名.github.io，否则可能会无法访问 安装Hexo在自己喜欢的地方创建文件夹，名称任意，用于存放Hexo，然后按住Shift + 鼠标右键会发现有个 单击它打开命令行窗口，输入 npm install hexo -g 开始安装Hexo 经过一段时间的等待，hexo就安装好了，此时可以输入 hexo -v 验证是否安装成功成功效果图： 然后输入 hexo init 开始初始化hexo，经过一段时间的等待，当看到Start blogging with Hexo！时，就代表初始化已经完成了，此时再输入 npm install 安装所需组件,安装完成后再输入 hexo g 然后输入 hexo s 开启服务，此时如果不出意外在浏览器输入localhost:4000就可以访问到首页了，然后hexo基本已经安装完毕了，下一步要开始上传到git了 配置git首先打开 Git Bash，设置用户名和邮箱 git config –global user.name “用户名”git config –global user.email “邮箱地址” 输入以下代码可查看配置信息 git config -l 完成后输入以下代码生成秘钥(输入后按下三次回车) ssh-keygen -t rsa -b 4096 -C “邮箱地址” 启动ssh-agent eval $(ssh-agent -s) 生成ssh key到ssh-agent ssh-add ~/.ssh/id_rsa 使用命令复制秘钥 clip &lt; ~/.ssh/id_rsa.pub 登录GitHub点击头像下的setting然后点击再点击将复制好的秘钥粘贴进去即可进去即可输入以下代码验证是否成功，若Hi后出现你的github名称，就代表秘钥添加成功 ssh -T git@github.com 配置hexo目录下的_config.yml ,deploy在文件的最下面1234deploy: type: git repository: 新建项目中的SSH branch: master 在此复制SSH地址，粘贴到repository中在命令行输入安装扩展 npm install hexo-deployer-git –save 完成后输入 hexo d -g 即可完成整个hexo的部署输入用户名.github.io即可访问]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
